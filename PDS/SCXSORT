./ ADD NAME=$README$ 0101-01157-01235-1310-00019-00046-00000-PST0705
Installation / readme for SCXSORT

There are 3 component for this package

MACRO    Is the Assembler macro named ID requitred to assemble the
         assembler routine. Put it into a library included in your
         SYSLIB concatenation for the assembly.

SOURCE   Is the single Assembler source deck of the function.

HELP     Is the documentation on how to use SCXSORT in Rexx programs.

Making SCXSORT available to your rexx program can be as simple as
link editing it to a load library that is within the JOBLIB/STEPLIB
concatenation when the rexx program runs. Myself, I have built a Rexx
function package under the name IRXFLOC which contains all the
assembler written rexx functions for the platform.

The HELP documentation should provide all the usage notes required.
./ ADD NAME=HELP     0105-96073-96204-1023-00077-00063-00000-PST0705
 Name:        SCXSORT

 Purpose:     Sort from and/or into REXX stem variables.                e

 Environment: REXX subroutine/function for all MVS/ESA environments.
              SCXSORT resides in the IRXFLOC "function package".

 Features:    All the capabilities of the system sort program are
              available.

              Use of stem variables is not mandatory. SCXSORT may be
              used to manipulate files as per normal.

              SORT's control statements are coded as values assigned
              to specific REXX variables. Each control statement
              uses a REXX variable name of the format SCX._____
              where _____ is the name of the control statement
              e.g. SCX.SORT = 'FIELDS=(1,8,BI,A)'

 Arguments:   There are two possible arguments; both are optional.

           1. The name of the stem variable containing the
              input "records". (If this argument is omitted, SORT
              will obtain the input records from SORTIN or as per
              the MODS control statement.)

              The argument (when used) must specify a stem variable
              name including the period. It should/must be enclosed
              within quotation marks.

              If there are non-existent variables within the range
              of stem.1 and stem.n, then stem.0 must contain the
              value of "n" to cause SCXSORT to ignore the
              non-existent variables.

           2. The name of the stem variable to receive the output
              "records".  (If this argument is omitted, SORT will
              dispose of the output records to SORTOUT or as per the
              MODS control statement.)

              The argument (when used) must specify a stem variable
              name including the period. It should/must be enclosed
              within quotation marks.

              SCXSORT normally uses stem.1 for the first output
              "record".  If stem.0 is assigned the value "n", then
              output begins at stem.n. This technique can be used
              to add entries to an existing range.

 Results:     Direct results for the REXX exec are only produced
              when argument two is used. In that case the stem
              variables are (re)filled and stem.0 contains the value
              of the number of the last stem filled.


 Notes:
    It is recommended that scx.RECORD always be used.  Default for
    stemmed input is scx.RECORD = 'TYPE=F,LENGTH=(length(stem.1))'.
    SCXSORT will abort when scx.RECORD is not assigned and stemmed
    output is requested but stemmed input is not.

    Misrepresentation of RECORD TYPE/LENGTH will create
    unpredictable results.

    If SCXSORT is to be used multiple times within one exec, ensure
    that only those scx.____ variables required for each SCXSORT are
    in force before the invocation. It may be necessary to DROP
    SCX.___ variables (e.g. scx.SUM = 'FIELDS=NONE')

    Control of SORT's message is accomplished through the $ORTPARM
    DDname. Once a particular use of SCXSORT is stable and SORT's
    messages are to be suppressed (and allocation of SYSOUT
    avoided), then $ORTPARM should be allocated to
    SYS1.UTILPARM(SORT@NOL)

    In certain situations, SCXSORT can be an alternative to EXECIO.

./ ADD NAME=MACRO    0102-98050-98050-1606-00049-00046-00000-PST0705
         MACRO
&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY
         LCLC  &U,&LBL
.*
.* Stelco macro used to:
.*    - generate the CSECT statement.
.*    - generate the USING, AMODE and RMODE statements for the CSECT.
.*    - generate an eye-catcher and date/time stamp (28 bytes total).
.*      (The values for date and time are the time of the Assembly.)
.*
.* The default for the USING statement is (register) 15.
.* Other defaults are as per the prototype above.
.*
.* If the CSECT requires multiple base registers, their specification
.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)
.*
.* This macro can also be used to generate only the eye-catcher and
.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO
.*
.* -----------------------Modification History-------------------------
.* 98-02-19 change from &SYSDATE to &SYSDATC
.*
&U       SETC  '15'
&LBL     SETC  ' '
         AIF   (K'&LABEL EQ 0).LBLSET
&LBL     SETC  '&LABEL'
.LBLSET  ANOP
         AIF   (T'&USING EQ 'O').USET
         AIF   ('&USING'(1,1) NE '(').ONEUSE
&U       SETC  '&USING'(2,K'&USING-2)
         AGO   .USET
.ONEUSE  ANOP
&U       SETC  '&USING'
.USET    ANOP
         AIF   ('&CSECT' EQ 'YES').CSECT
&LBL     DS    0H
         B     *+32
         AGO   .STAMP
.CSECT   ANOP
&LBL     CSECT
&LBL     AMODE &AMODE
&LBL     RMODE &RMODE
         USING &LABEL,&U
         BC    15,32(,15)
.STAMP   ANOP
         DS    CL4
         DC    CL8'&LBL'
         DC    CL16'&SYSDATC &SYSTIME'
         MEND
./ ADD NAME=SOURCE   0140-95181-01235-1315-00824-00355-00000-PST0705
XSORT    TITLE            '<< REXX - SORT from/into REXX stems         X
                                                      Documentation >>'
* Name:        SCXSORT
*
* Purpose:     Invoke the system sort routine and optionally use
*              'stemmed' input variables and/or 'stemmed' output.
*
* Environment: REXX subroutine/function for Address TSO or MVS
*
* Features:    All SORT control statements are made available via
*              values for REXX variable names. Each REXX variable name
*              is composed of a stem of SCX. followed by the name of a
*              SORT control statement.
*              e.g. SCX.RECORD = 'TYPE=V,LENGTH=(.... '
*
* Arguments:
*  1. The name of a stem variable or null. If this argument is null,
*     this routine (of its own) will not establish an E15 exit and SORT
*     will defer to the control statements values; i.e. default to
*     SORTIN or use the MODS settings.
*
*     If a stemmed variable is to be used:
*        - specify the name of the stem variable including the '.'
*        - if there are unitialized variables between stem.1 and
*          stem.n, then set the value of stem.0 to 'n' so that all
*          initialized stems within the range will be sorted.
*
*  2. The name of a stem variable or null. If this argument is null,
*     this routine (of its own) will not establish an E35 exit and SORT
*     will defer to the control statements values; i.e. default to
*     SORTOUT or use the MODS settings
*
*     If a stemmed variable is to be used:
*        - specify the name of the stem variable including the '.'
*        - if the variable stem already has a series of 'tails' up to
*          n-1, then pre-set stem.0 = n so that the sort will start
*          adding records at stem.n
*        - SCXSORT will (re)set the value of 'stem.0' to the number of
*          output variables.
*
* Notes:
*     The RECORD control statement should be used for stemmed input
*     and/or output.  This routine will check the variable SCX.RECORD
*     and use both the TYPE= and LENGTH= operands.  Misrepresentation
*     of the RECORD parameters will yield unpredicatble results.
*
*     If stemmed input is used and
*        - if SCX.RECORD is un-initialized or 'TYPE=F'
*          (without LENGTH= operands) is coded, then
*          RECORD TYPE=F,LENGTH=(length(stem.1)) is forced.
*        - if TYPE=V is coded, the E15 exit portion of this routine
*          will create variable length records. This is recommended
*          when sorting from stems to stems.
*
*     If stemmed output is used and
*        - variable length records are being passed to build the stems,
*          then TYPE=V must be coded (i.e. TYPE=V is not implied.)
*        - TYPE=V is not coded and LENGTH= is not coded (or forced as
*          per above), then this routine aborts the SORT.
*        - TYPE=V is coded, the LENGTH= operands are ignored by this
*          routine.
*
         TITLE            '<< REXX - SORT from/into REXX stems         X
                                                     System Linkage >>'
         PRINT   GEN
SCXSORT  ID    R12
         PRINT NOGEN
         SPACE 2
         STM   R14,R12,12(R13)
         LR    R12,R15
         ST    R13,SAVEAREA+4
         LA    R15,SAVEAREA
         ST    R15,8(,R13)
         LR    R13,R15
         XC    RC,RC
         B     MAINLINE
         SPACE 3
RC       DS    0F
         DS    AL1
RC1      DS    AL1
RC2      DS    AL1
RC3      DS    AL1
         SPACE 1
SAVEAREA DS    18F
         SPACE 3
RTNXT    DS    0H
         L     R13,SAVEAREA+4
         XC    8(4,R13),8(R13)
         XC    16(4,R13),16(R13)   R15 (return code) always
         LM    R14,R12,12(R13)        get set to zero.
         BR    R14
         TITLE            '<< REXX - SORT from/into REXX stems         X
                                                Parse the Arguments >>'
MAINLINE DS    0H
         USING EFPL,R1
         USING ENVBLOCK,R8
         USING IRXEXTE,R9
         USING EVALBLOCK,R11
         USING SHVBLOCK,R14
         ST    R0,A_ENVBLK
         LR    R8,R0               Address the environment block.
         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.
         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK.
         L     R11,0(,R11)
         ST    R9,A_IRXEXTE        Save address of the vector table.
         DROP  R8
         SR    R0,R0
         ST    R0,SHVNAMA-SHVBLOCK+@SHV
         ST    R0,E15_GOTMAIN      Presume no storage for stems.
         ST    R0,VE15             Presume no stemmed input.
         ST    R0,VE35             Presume no stemmed output
         ST    R0,IN_LRECL
         ST    R0,OUT_LRECL
         ST    R0,LRECL            Clear LENGTH=
         MVI   RECFM,C' '             and TYPE=
         MVI   TRTABLE-1,X'FF'
         BAL   R14,STRIP           Strip out arg(1).
         B     GET_ARG2            Arg(1) not specified.
         CLI   0(R4),C'.'          Stemmed input?
         BNE   ARG1_ERR               -no -
         LA    R14,TAIL_IN-1       Calculate starting address
         SR    R14,R15                of input stem name
         ST    R14,A_STEM_IN             and save it.
         EX    R15,MVC_STEMIN      Pick-up the name of the input stem.
         LA    R0,FROM_STEM        Entry address
         ST    R0,VE15                for E15 exit
         OI    VE15,X'80'                in AMODE 31.
         B     GET_ARG2
MVC_STEMIN  MVC  0(0,R14),0(R3)
         SPACE 1
GET_ARG2 DS    0H
         BAL   R14,STRIP           Strip out arg(2).
         B     ARGS_DONE           Arg(2) not specified
         CLI   0(R4),C'.'          Stemmed output?
         BNE   ARG2_ERR               -no -
         LA    R14,TAIL_OUT-1      Calculate starting address
         SR    R14,R15                of output stem name
         ST    R14,A_STEM_OUT            and save it.
         EX    R15,MVC_STEMIN      Pick-up the name of the output stem.
         LA    R0,TO_STEM          Entry address
         ST    R0,VE35                for E35 exit
         OI    VE35,X'80'                in AMODE 31.
         B     ARGS_DONE
         TITLE            '<< REXX - SORT from/into REXX stems         X
                                Collect the SORT control statements >>'
STMNT_TABLE DS 0C
          DC   AL1(L'@SORT)
@SORT     DC   C'SORT',AL1(L'@ALTSEQ)
@ALTSEQ   DC   C'ALTSEQ',AL1(L'@INCLUDE)
@INCLUDE  DC   C'INCLUDE',AL1(L'@INREC)
@INREC    DC   C'INREC',AL1(L'@MERGE)
@MERGE    DC   C'MERGE',AL1(L'@MODS)
@MODS     DC   C'MODS',AL1(L'@OMIT)
@OMIT     DC   C'OMIT',AL1(L'@OUTFIL)
@OUTFIL   DC   C'OUTFIL',AL1(L'@OUTREC)
@OUTREC   DC   C'OUTREC',AL1(L'@SUM)
@SUM      DC   C'SUM',AL1(L'@RECORD)
@RECORD   DC   C'RECORD'           Procees RECORD statement last.
          DC   AL1(0)              End-of-table indicator.
@SCX      DC   C'SCX.'
CONTROL   DS   CL8
MVC_CONTROL  MVC  CONTROL(0),1(R4)
MVC2_CONTROL MVC  1(0,R3),1(R4)
         SPACE 2
ARGS_DONE  DS  0H
         LA    R1,4087             Maximum of 4K for statements.
         ST    R1,SHVBUFL-SHVBLOCK+@SHV
         LA    R0,9(,R1)
      GETMAIN  R,LV=(R0)
         ST    R1,@CONTROLS        Save the address of the area.
         LA    R3,2(,R1)
         LA    R4,STMNT_TABLE
         SR    R5,R5
         LA    R0,@SCX
         ST    R0,SHVNAMA-SHVBLOCK+@SHV
         MVI   SHVCODE-SHVBLOCK+@SHV,SHVFETCH
STMNT_LOOP  DS  0H
         IC    R5,0(R4)            Get the length of the statement name
         LA    R0,4(,R5)           Hence length of variable name.
         ST    R0,SHVNAML-SHVBLOCK+@SHV
         LR    R1,R5               Pick-up
         BCTR  R1,0                   this control statement's name
         EX    R1,MVC_CONTROL            to complete the variable name.
         LA    R0,2(R5,R3)         Address where variable
         ST    R0,SHVVALA-SHVBLOCK+@SHV  value is placed.
*
* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
         L     R15,IRXEXCOM        Get routine's address from vector.
         L     R0,A_ENVBLK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXCOM_FAILURE
         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV
         BO    NEXT_STMNT
         LR    R1,R5               Pick-up
         BCTR  R1,0                   this control statement's name
         EX    R1,MVC2_CONTROL           to complete SORT's statement.
         LA    R1,2(R1,R3)         Enclose
         MVI   0(R3),C' '            it in
         MVI   0(R1),C' '               blanks.
         L     R3,SHVVALA-SHVBLOCK+@SHV
         A     R3,SHVVALL-SHVBLOCK+@SHV
         L     R1,@CONTROLS
         LA    R1,4087(,R1)
         SR    R1,R3
         ST    R1,SHVBUFL-SHVBLOCK+@SHV
NEXT_STMNT  DS  0H
         LA    R4,1(R5,R4)         Address of next statement.
         CLI   0(R4),X'00'         More statements?
         BNE   STMNT_LOOP             -yes-
         L     R6,SHVVALA-SHVBLOCK+@SHV  Where was the last value put?
         ST    R3,SHVVALA-SHVBLOCK+@SHV  Here's where to put more.
         L     R1,@CONTROLS        Calculate
         SR    R3,R1                  length
         BCTR  R3,0
         BCTR  R3,0
         STH   R3,0(,R1)                 of SORT's control statements.
         TITLE            '<< REXX - SORT from/into REXX stems         X
                                       Analize the RECORD statement >>'
         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV
         BO    IF_E15
         CLC   =CL5'TYPE=',0(R6)
         BNE   *+14
         MVC   RECFM,5(R6)
         LA    R6,7(,R6)
         SPACE 1
         SR    R14,R14             Indicate LRECL not set.
         CLC   0(8,R6),=CL8'LENGTH=(' Is there a LENGTH= operand?
         BE    LENGTH_GIVEN             -yes-
         CLC   0(7,R6),=CL8'LENGTH=(' Is there a LENGTH= operand?
         BNE   NO_MORE_LENGTHS          -no -
         LA    R6,7(,R6)
         B     LENGTH_GIVEN+4
LENGTH_GIVEN   DS  0H
         LA    R6,8(,R6)           Point to the operand.
         SPACE 1
         MVI   TRTABLE-1,X'FF'     Delimit
         MVC   TRTABLE,TRTABLE-1      the search
         MVI   TRTABLE+C'0',X'00'        at any
         MVC   TRTABLE+C'1'(9),TRTABLE+C'0' non-numeric but
         MVI   TRTABLE+C',',X'01'              comma is special.
         SR    R2,R2               Pre-clear R2.
         LA    R1,6(,R6)           Pre-set maximum delimiter address.
         TRT   0(7,R6),TRTABLE     Find delimiter of numerics.
         BZ    NO_MORE_LENGTHS     Too many numerics.
         SR    R1,R6           *\  Calculate length of the operand
         LA    R1,X'6F'(,R1)     )    as a machine instruction.
         BNP   NO_MORE_LENGTHS */  (cc from SR above) Null operand.
         EX    R1,PACK@R6          Pick-up
         CVB   R14,DBLWD              length of the operand
         ST    R14,LRECL                 and save it.
NO_LENGTH1 DS  0H
         BCT   R2,NO_MORE_LENGTHS  Was comma the delimiter?  -no -
         LA    R6,1(,R1)                                     -yes-
         LA    R1,6(,R6)           Pre-set maximum delimiter address.
         TRT   0(7,R6),TRTABLE     Find delimiter of numerics.
         BZ    NO_MORE_LENGTHS     Too many numerics.
         SR    R1,R6           *\  Calculate length of the operand
         LA    R1,X'6F'(,R1)     )    as a machine instruction.
         BNP   NO_MORE_LENGTHS */  (cc from SR above) Null operand.
         EX    R1,PACK@R6          Pick-up
         CVB   R0,DBLWD               length of the operand
         ST    R0,IN_LRECL               and save it.
NO_LENGTH2 DS  0H
         BCT   R2,NO_MORE_LENGTHS  Was comma the delimiter?  -no -
         LA    R6,1(,R1)                                     -yes-
         LA    R1,6(,R6)           Pre-set maximum delimiter address.
         TRT   0(7,R6),TRTABLE     Find delimiter of numerics.
         BZ    NO_MORE_LENGTHS     Too many numerics.
         SR    R1,R6           *\  Calculate length of the operand
         LA    R1,X'6F'(,R1)     )    as a machine instruction.
         BNP   NO_MORE_LENGTHS */  (cc from SR above) Null operand.
         EX    R1,PACK@R6          Pick-up
         CVB   R0,DBLWD               length of the operand
         ST    R0,OUT_LRECL              and save it.
NO_MORE_LENGTHS  DS  0H   Propogate length operand forward.
         L     R1,IN_LRECL         Is
         LTR   R1,R1                  E15 length set?
         BNZ   *+8                       -yes-
         ST    R14,IN_LRECL              -no -   Use global length.
         SPACE 1
         L     R2,IN_LRECL         Get E15 length
         L     R1,OUT_LRECL        Is
         LTR   R1,R1                  E35 length set?
         BNZ   IF_E15                    -yes-
         ST    R2,OUT_LRECL              -no -   Use E15 length.
IF_E15   DS    0H
         TM    VE15,X'80'          Input stems?
         BZ    IF_E35                 -no -
         L     R15,IN_LRECL        Is RECORD LENGTH=
         LTR   R0,R15                 set?
         BNZ   E15_GETMAIN               -yes-
         MVI   TAIL_IN,C'1'        Set the stem's tail to one.
         L     R1,A_STEM_IN        Get address of the variable name and
         ST    R1,SHVNAMA-SHVBLOCK+@SHV  let EXCOM know about it.
         LA    R3,TAIL_IN+1        Calculate length of variable name
         SR    R3,R1                  including the tail and
         ST    R3,SHVNAML-SHVBLOCK+@SHV  let EXCOM know about it.
         L     R3,SHVBUFL-SHVBLOCK+@SHV
         L     R15,IRXEXCOM        Get routine's address from vector.
         L     R0,A_ENVBLK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXCOM_FAILURE
         ST    R3,SHVBUFL-SHVBLOCK+@SHV
         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV
         BO    NO_STEM_IN
         L     R0,SHVVALL          Get the length(stem.1)
         CLI   RECFM,C'V'          RECORD TYPE=V?
         BNE   *+8                    -no -
         A     R0,A4                  -yes-   RDW adjustemnt.
         SPACE 1
         ST    R0,IN_LRECL         Save the LRECL
         CVD   R0,DBLWD            Convert
         OI    DBLWD+7,X'0F'          to decimal
         L     R1,@CONTROLS        Address of control cards.
         LH    R0,0(,R1)           Length used already.
         AR    R1,R0               I can put data here.
         CLI   RECFM,C' '          Did we find a RECORD statement?
         BNE   FORCE_LENGTH           -yes-
         MVI   0(R1),C' '          Build
         MVC   1(6,R1),@RECORD        RECORD
         MVI   7(R1),C' '
         MVC   8(5,R1),=CL5'TYPE='       TYPE=
         MVI   13(R1),C'F'                    F
         MVI   RECFM,C'F'          Remember the RECFM
         LA    R1,14(,R1)          Adjust pick-up address.
FORCE_LENGTH  DS  0H
         MVI   0(R1),C','          Build
         MVC   1(8,R1),=CL8'LENGTH=('  LENGTH=
         UNPK  9(5,R1),DBLWD+5(3)        operand
         MVI   14(R1),C')'                  .
         LA    R0,15(,R1)          Re-calculate
         L     R1,@CONTROLS           length of control
         SR    R0,R1                     statements
         STH   R0,0(,R1)                    and save the result.
         L     R1,OUT_LRECL        Has the output LRECL
         LTR   R1,R1                  been esatblished?
         BNZ   *+10                      -yes-
         MVC   OUT_LRECL,IN_LRECL        -no -   Default
         SPACE 1
         L     R0,IN_LRECL         Re-set R0 for GETMAIN
E15_GETMAIN  DS  0H
         LR    R1,R0
         LA    R0,11(,R1)         (4 of 11 could be avoided, but...)
         N     R0,X_FFFFFFF8       Bits 29-31 become zero.
         ST    R0,IN_LRECL               and save result.
       GETMAIN R,LV=(R0)
         ST    R1,E15_GOTMAIN      Remember the address.
IF_E35   DS    0H
         TM    VE35,X'80'          Output stems?
         BZ    PRE_SORT               -no -
         LA    R0,1                Presume
         ST    R0,OUT_COUNT           we start at stem.1
         MVI   TAIL_OUT,C'0'       Set the stem's tail to zero.
         L     R1,A_STEM_OUT       Get address of the variable name and
         ST    R1,SHVNAMA-SHVBLOCK+@SHV  let EXCOM know about it.
         LA    R3,TAIL_OUT+1       Calculate length of variable name
         SR    R3,R1                  including the tail and
         ST    R3,SHVNAML-SHVBLOCK+@SHV  let EXCOM know about it.
         L     R3,SHVBUFL-SHVBLOCK+@SHV
         L     R15,IRXEXCOM        Get routine's address from vector.
         L     R0,A_ENVBLK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXCOM_FAILURE
         ST    R3,SHVBUFL-SHVBLOCK+@SHV
         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV  Did that variable exist?
         BO    NO_STEM_OUT                      -no -
         L     R6,SHVVALA-SHVBLOCK+@SHV
         L     R1,SHVVALL-SHVBLOCK+@SHV  Use the length of the value
         LA    R1,X'6F'(,R1)                for the
         EX    R1,PACK@R6                      PACK instruction.
         CVB   R1,DBLWD
         LTR   R1,R1               Is the value
         BP    *+8                    greater than zero?   -yes-
         LA    R1,1                Substitute 1.
         SPACE 1
         ST    R1,OUT_COUNT        Tail number is ready.
NO_STEM_OUT  DS  0H
         CLI   RECFM,C'V'          Has RECORD TYPE=V been specified?
         BE    PRE_SORT               -yes-  We hope that will work.
         L     R15,OUT_LRECL       Is a stem length
         LTR   R15,R15                available?
         BZ    NO_OUT_LRECL              -no -  hang-up now.
         MVI   RECFM,C'F'          Presumption.
         TITLE            '<< REXX - SORT from/into REXX stems         X
                                          Pre-sets for the E15 exit >>'
PRE_SORT DS    0H
         TM    VE15,X'80'
         BZ    START_SORT
         SR    R0,R0
         ST    R0,IN_LIMIT
         ST    R0,IN_COUNT
         MVI   SHVCODE-SHVBLOCK+@SHV,SHVFETCH
         MVI   TAIL_IN,C'0'
         L     R1,A_STEM_IN        Get address of the variable name and
         ST    R1,SHVNAMA-SHVBLOCK+@SHV  let EXCOM know about it.
         LA    R3,TAIL_IN+1        Calculate length of variable name
         SR    R3,R1                  including the tail and
         ST    R3,SHVNAML-SHVBLOCK+@SHV  let EXCOM know about it.
         L     R3,SHVBUFL-SHVBLOCK+@SHV
         L     R15,IRXEXCOM        Get routine's address from vector.
         L     R0,A_ENVBLK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXCOM_FAILURE
         ST    R3,SHVBUFL-SHVBLOCK+@SHV
         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV  Did that variable exist?
         BO    NO_STEM0_IN                      -no -
         L     R6,SHVVALA-SHVBLOCK+@SHV
         L     R1,SHVVALL-SHVBLOCK+@SHV  Use the length of the value
         LA    R1,X'6F'(,R1)                for the
         EX    R1,PACK@R6                      PACK instruction.
         CVB   R1,DBLWD
         LTR   R1,R1               Is the value
         BP    *+6                    greater than zero?   -yes-
         SR    R1,R1               Substitute zero.
         SPACE 1
         ST    R1,IN_LIMIT         Input limit count is ready.
NO_STEM0_IN  DS  0H
         L     R0,A_STEM_IN
         ST    R0,SHVNAMA-SHVBLOCK+@SHV
         L     R0,IN_LRECL
         L     R1,E15_GOTMAIN
         CLI   RECFM,C'V'
         BNE   *+12
         LA    R1,4(,R1)
         S     R0,A4
         SPACE 1
         ST    R0,SHVBUFL-SHVBLOCK+@SHV
         ST    R1,SHVVALA-SHVBLOCK+@SHV
         B     START_SORT          Ready for SORT to do its thing.
         TITLE            '<< REXX - SORT from/into REXX stems         X
                                Run SORT.   Set result.   Clean-up. >>'
START_SORT  DS  0H
         LA    R1,SORT_PLIST
         LINK  EP=SORT
         SPACE 3
         CVD   R15,DBLWD           Convert the return code
         UNPK  EVALBLOCK_EVDATA(5),DBLWD+5(3)  into
         OI    EVALBLOCK_EVDATA+4,X'F0'          ebcidic format.
         LA    R2,5                Maximum length of the value.
         LA    R3,4                Maximum leading zeroes.
         LA    R4,*+4              Top-of-loop address
         CLI   EVALBLOCK_EVDATA,C'0'  Leading zero?
         BNE   RESULT_SET                -no -
         BCTR  R2,0                Decrement the length
         MVC   EVALBLOCK_EVDATA(4),EVALBLOCK_EVDATA+1  Shift the data.
         BCTR  R3,R4               Count and loop.
RESULT_SET  DS 0H
         ST    R2,EVALBLOCK_EVLEN
         TM    VE35,X'80'          Output stems?
         BZ    STEM0_SET              -no -
         MVI   SHVCODE-SHVBLOCK+@SHV,SHVSTORE
         MVI   TAIL_OUT,C'0'       Stem.0 is qualified variable name.
         L     R0,A_STEM_OUT       Where is the variable name because
         ST    R0,SHVNAMA-SHVBLOCK+@SHV  EXCOM needs to know.
         LA    R2,TAIL_OUT+1       Calculate
         SR    R2,R0                  the length of the varaible name
         ST    R2,SHVNAML-SHVBLOCK+@SHV  and let EXCOM know about it.
         L     R2,OUT_COUNT        Convert
         BCTR  R2,0                   the
         CVD   R2,DBLWD                  value
         OI    DBLWD+7,X'0F'                to
         UNPK  EVALBLOCK_EVDATA+7(7),DBLWD+4(4)  ebcdic format.
         LA    R0,EVALBLOCK_EVDATA+7
         LA    R2,EVALBLOCK_EVDATA+14
         LA    R3,6                Maximum leading zeroes.
         LA    R4,*+4              Top-of-loop address
         CLI   EVALBLOCK_EVDATA+7,C'0'  Leading zero?
         BNE   *+14                        -no -
         BCTR  R2,0                Decrement the length
         MVC   EVALBLOCK_EVDATA+7(6),EVALBLOCK_EVDATA+8 Shift the data.
         BCTR  R3,R4               Count and loop.
         SPACE 1
         SR    R2,R0
         ST    R0,SHVVALA-SHVBLOCK+@SHV
         ST    R2,SHVVALL-SHVBLOCK+@SHV
         L     R15,IRXEXCOM        Get routine's address from vector.
         L     R0,A_ENVBLK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXCOM_FAILURE
STEM0_SET  DS  0H
         SPACE 3
         LA    R1,4095
         LA    R0,1(,R1)
         L     R1,@CONTROLS
      FREEMAIN R,LV=(R0),A=(R1)
         L     R1,E15_GOTMAIN
         LTR   R1,R1
         BZ    RTNXT
         L     R0,IN_LRECL
      FREEMAIN R,LV=(R0),A=(R1)
         B     RTNXT
         SPACE 3
SORT_PLIST DS  0A
@CONTROLS DS   A                   Address of SORT control statements.
VE15     DS    A
VE35     DS    A
         DC    X'FFFFFFFF'
         TITLE            '<< REXX - SORT from/into REXX stems         X
                  Place record into the stem variable. The E35 exit >>'
         DROP  R12
TO_STEM  DS    0D
         STM   R14,R12,12(R13)
         USING TO_STEM,R15
         L     R12,VSCXSORT
         DROP  R15
         USING SCXSORT,R12
         ST    R13,E@5SAVE+4
         LA    R15,E@5SAVE
         ST    R15,8(,R13)
         LR    R13,R15
         XC    E@5RC,E@5RC
         B     E35MAIN
         SPACE 3
E@5RC    DS    F
         SPACE 1
E@5SAVE  DS    18F
         SPACE 3
E@5XT    DS    0H
         L     R13,E@5SAVE+4       SORT's save area.
         XC    8(4,R13),8(R13)     Break the save area chain.
         L     R15,E@5RC           R15 = exit return code.
         L     R14,12(,R13)        SORT's return address.
         LM    R0,R12,20(R13)      SORT's registers.
         BR    R14                 Return to SORT
         SPACE 3
E35MAIN  DS    0H
         L     R9,A_IRXEXTE        Get address of the vector table.
         MVI   SHVCODE-SHVBLOCK+@SHV,SHVSTORE
         L     R1,0(,R1)           Get address of the 'record'.
         MVI   E@5RC+3,8           Presume we are to raise e-o-f.
         LTR   R1,R1               Is there a record?
         BZ    E@5XT                  -no -  made good presumption.
         MVI   E@5RC+3,4           Tell SORT we liked what we got.
         L     R0,OUT_LRECL        Get LRECL (when RECFM=F).
         CLI   RECFM,C'V'          Dealing with RECFM=V
         BNE   OUT_F                  -no -
         ICM   R0,B'0011',0(R1)    Extract the actual LRECL and
         S     R0,A4                  hence the length of data.
         LA    R1,4(,R1)           Get address of record data.
OUT_F    DS    0H
         ST    R0,SHVVALL-SHVBLOCK+@SHV
         ST    R1,SHVVALA-SHVBLOCK+@SHV
         L     R1,OUT_COUNT        What tail
         CVD   R1,DBLWD               do we create.
         LA    R1,1(,R1)           Increment the count
         ST    R1,OUT_COUNT           for the next pass.
         OI    DBLWD+7,X'0F'       Ensure an ebcdic
         UNPK  TAIL_OUT(7),DBLWD+4(4)  Use maximum of 7 digits.
         L     R0,A_STEM_OUT       Get address of variable name
         ST    R0,SHVNAMA-SHVBLOCK+@SHV  for EXCOM
         LA    R1,TAIL_OUT+7       Maximum
         SR    R1,R0                  variable name length.
         CLI   TAIL_OUT,C'0'       Any high order zeroes?
         BNE   TAIL_OUT_SET           -no -
         LA    R15,TAIL_OUT
         LA    R2,*+6              Top-of-loop address.
         BCTR  R1,R2               Already know about leftmost byte.
         SPACE 1
         LA    R15,1(,R15)         Point right one byte.
         CLI   0(R15),C'0'         High order zero?
         BNE   *+6                    -no -
         BCTR  R1,R2               Decrement length and loop back.
         SPACE 1
         MVC   TAIL_OUT(6),0(R15)  Calculate length of variable name
TAIL_OUT_SET  DS  0H
         ST    R1,SHVNAML-SHVBLOCK+@SHV
         L     R15,IRXEXCOM        Get routine's address from vector.
         L     R0,A_ENVBLK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXCOM_FAILURE
         B     E@5XT
         TITLE            '<< REXX - SORT from/into REXX stems         X
                  Create records from a stem variable. The E15 exit >>'
         DROP  R12
FROM_STEM DS    0D
         STM   R14,R12,12(R13)
         USING FROM_STEM,R15
         L     R12,VSCXSORT
         DROP  R15
         USING SCXSORT,R12
         ST    R13,E@5SAVE+4
         LA    R15,E@5SAVE
         ST    R15,8(,R13)
         LR    R13,R15
         LA    R0,12               Presume a record get be generated.
         ST    R0,E@5RC
         SPACE 3
         L     R9,A_IRXEXTE        Get address of the vector table.
         L     R8,E15_GOTMAIN      Address of record buffer.
         ST    R8,0(,R1)           Tell SORT about it.
         L     R1,IN_COUNT         What
NEXT_INPUT  DS  0H
         LA    R1,1(,R1)              tail number
         CVD   R1,DBLWD                  do we create?
         ST    R1,IN_COUNT         Save the number for the next iterate
         OI    DBLWD+7,X'0F'       Ensure an ebcdic.
         UNPK  TAIL_IN(7),DBLWD+4(4)   Use maximum of 7 digits.
         L     R0,A_STEM_IN        Get address of variable name.
         LA    R1,TAIL_IN+7        Maximum
         SR    R1,R0                  variable name length.
         CLI   TAIL_IN,C'0'        Any high order zeroes?
         BNE   TAIL_IN_SET            -no -
         LA    R15,TAIL_IN         Start at the left.
         LA    R2,*+6              Top-of-loop address.
         BCTR  R1,R2               Already know about leftmost byte.
         SPACE 1
         LA    R15,1(,R15)         Point right one byte.
         CLI   0(R15),C'0'         Still high order zero?
         BNE   *+6                    -no -   Jump out of the loop.
         BCTR  R1,R2               Decrement length and loop back.
         SPACE 1
         MVC   TAIL_IN(6),0(R15)   Pick-up significant digits.
TAIL_IN_SET   DS  0H
         ST    R1,SHVNAML-SHVBLOCK+@SHV  for EXCOM
         L     R15,IRXEXCOM        Get routine's address from vector.
         L     R0,A_ENVBLK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXCOM_FAILURE
         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV
         BO    NULL_IN
         CLI   RECFM,C'V'
         BNE   E15_EXIT
         L     R0,SHVVALL-SHVBLOCK+@SHV
         A     R0,A4
         SLL   R0,16
         STCM  R0,B'1111',0(R8)
E15_EXIT DS    0H
         L     R13,E@5SAVE+4       SORT's save area.
         XC    8(4,R13),8(R13)     Break the save area chain.
         LM    R14,R0,12(R13)      SORT's registers
         L     R15,E@5RC           R15 = exit return code.
         LR    R1,R8
         LM    R2,R12,28(R13)      SORT's registers.
         BR    R14                 Return to SORT
NULL_IN  DS    0H
         L     R1,IN_COUNT
         C     R1,IN_LIMIT
         BL    NEXT_INPUT
         MVI   E@5RC+3,8           Indicate end-of-input.
         B     E@5XT
         TITLE            '<< REXX - SORT from/into REXX stems         X
                     Subroutine to Strip Leading && Trailing Blanks >>'
* Registers upon entry
*    R10 ==> argument table entry
*    R14 ==> exit address when agrument is null
*    R14+4=> normal exit
*
* Registers upon exit
*    R10 ==> next argument table entry.
*    R2    = 0 (zero)
*    R3  ==> leftmost non-blank byte of argument
*    R4  ==> rightmost non-blank byte of argument
*    R15   = R4 - R3 (length of argument minus 1)
         SPACE 2
HEXFF    DC    X'FFFFFFFFFFFFFFFF'
         DS    XL1
TRTABLE  DS    XL256
         SPACE 1
TRT3     TRT   0(0,R3),TRTABLE
         SPACE 2
         USING ARGTABLE_ENTRY,R10
STRIP    DS    0H
         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?
         BER   R14                              -no -
         L     R15,ARGTABLE_ARGSTRING_LENGTH
         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.
         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.
         SPACE 1
         LTR   R15,R15             Does the argument have any length?
         BZR   R14                    -NO - take abnormal exit.
         LA    R4,0(R15,R3)        Point just beyond ARG.
         MVC   TRTABLE,TRTABLE-1   Set to
         MVI   TRTABLE+C' ',X'00'     bypass blanks.
         BCTR  R15,0               Set length for TRT instruction.
         EX    R15,TRT3            Skip to non-blank.
         BZR   R14                 When all blank.
         LR    R3,R1               Re-set starting address.
STRIP@R  DS    0H
         BCTR  R4,0                Backpedal 1 byte.
         CLI   0(R4),X'40'         (still) at a blanK?
         BNE   STRIPPED               -no -
         CR    R4,R3                  -yes-  More to inspect?
         BH    STRIP@R                          -yes-
STRIPPED DS    0H
         LR    R15,R4              Calculate
         SR    R15,R3                 length of ARG - 1.
         SR    R2,R2               Pre-clear R2 for TRT
         XC    TRTABLE,TRTABLE     Clear translate table.
         BC    15,4(,R14)          Take normal exit.
         TITLE            '<< REXX - SORT from/into REXX stems         X
                                                   Error Conditions >>'
*
* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
SAY_LIT        DC    CL8'WRITE   '
SAY_BUFF       DS    A
SAY_LEN        DS    F
SAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')
COM_FAIL DC    C'IRXEXCOM failed. Return code=     .'
ARG_MSG  DC    C'1st argument not terminated by ''.'''
NO_OUT_LRECL_MSG  DC  C'Output stem length can not be determined; SORT a
               aborted.'
         SPACE 2
NO_STEM_IN     DS    0H
         MVC   TAIL_IN+1(16),=C' does not exist.'
         L     R15,SHVNAMA
         LA    R0,TAIL_IN+17
         SR    R0,R15
         B     SAY_CALL
         SPACE 1
EXCOM_FAILURE  DS    0H
         LA    R15,COM_FAIL
         ORG   *-4
         DC    X'00000000'
         LA    R0,L'COM_FAIL
         B     SAY_CALL
         SPACE 1
NO_OUT_LRECL  DS  0H
         LA    R15,NO_OUT_LRECL_MSG
         LA    R0,L'NO_OUT_LRECL_MSG
         B     SAY_CALL
         SPACE 1
ARG1_ERR DS    0H
         MVC   ARG_MSG(3),=CL3'1st'
ARG_ERR  DS    0H
         LA    R15,ARG_MSG
         LA    R0,L'ARG_MSG
         B     SAY_CALL
         SPACE 1
ARG2_ERR DS    0H
         MVC   ARG_MSG(3),=CL3'2nd'
         B     ARG_ERR
         SPACE 2
SAY_CALL DS    0H
         ST    R15,SAY_BUFF
         ST    R0,SAY_LEN
         LA    R1,SAY_PLIST
         L     R0,A_ENVBLK
         L     R15,IRXSAY
         BALR  R14,R15
         L     R13,SAVEAREA+4
         XC    8(4,R13),8(R13)
         LM    R14,R12,12(R13)
         LA    R15,40
         BR    R14
         TITLE            '<< REXX - SORT from/into REXX stems         X
                                    Global data areas and constants >>'
         SPACE 2
DBLWD    DS    D
         SPACE 2
A_ENVBLK DS    A
A_IRXEXTE  DS  A
A_STEM_IN  DS  A
A_STEM_OUT DS  A
OUT_COUNT  DS  F
IN_COUNT DS    F
IN_LIMIT DS    F
A4       DC    A(4)
X_FFFFFFF8  DS  0F
MINUS8   DC    F'-8'
         SPACE 1
VSCXSORT DC    V(SCXSORT)
         SPACE 1
PLIST_EXCOM DC A(EXCOM_LIT,0,0)
         DC    A(@SHV+X'80000000')
         SPACE 1
@SHV     DS    0A
         DC    2A(0)
         DC    C'S'
         DS    XL3'000000'
         DC    5A(0)
         SPACE 1
EXCOM_LIT DC   CL8'IRXEXCOM'
E15_GOTMAIN  DS  A
LRECL    DS    F
IN_LRECL DS    F
OUT_LRECL DS   F
         SPACE 1
PACK@R6  PACK  DBLWD(0),0(0,R6)
         SPACE 1
STEM_IN  DS    0CL250
         DS    CL245
TAIL_IN  DS    CL7
         SPACE 2
STEM_OUT DS    0CL250
         DS    CL245
TAIL_OUT DS    CL7
RECFM    DS    C
         SPACE 2
         LTORG
         TITLE            '<< REXX - SORT from/into REXX stems         X
                                                 DSECTs and EQUates >>'
         YREGS
         SPACE 2
       IRXENVB
         SPACE 2
       IRXEXTE
         SPACE 2
       IRXSHVB
         SPACE 2
       IRXEFPL
         SPACE 2
      IRXARGTB
         SPACE 2
      IRXEVALB
         SPACE 2
         END   SCXSORT
