./ ADD NAME=HELP     0100-01157-01157-1131-00054-00054-00000-PST0705
 Name:        SCCPDSD

 Purpose:     Obtain selected directory entries from the specified
              DDname into a stemmed variable or into the data stack.

 Environment: REXX subroutine/function for all MVS/ESA environments.
              SCCD2O resides in the IRXFLOC "function package".


 Arguments:
           1. The DDname of the library. If the same DDname is to
              be used by SCCPDSR, currently only three values
              are allowed namely PDS1, PDS2, and PDS3. (Removal of
              this limitation is the planned enhancement.)

              The DDname must be pre-allocated to the library. That
              allocation must not be done at the member level.

           2. The selection criteria. The criteria is composed of
              natural characters and/or the 'wildcard' values
              '*' and '%'

              Refer to the WILDCARD function for details of how this
              criteria may be used.

           3. The name of the REXX stem variable to receive the
              directory entries.  The caller must ensure this
              specification is enclosed within quotes.

              If argument 3 is not specified (or specified as null),
              the directory entries are placed in the data stack.


 Results: (when 'stem.' is specified at argument 3)
              'stem.0' contains a count of the number of directory
              entries.

              'stem.1' through 'stem.stem.0' contains the individual
              directory entries.

          (when argument 3 is null):
              The data stack contains directory entries read in FIFO
              order.

          (independent of argument 3)
              As a REXX subroutine/function SCCPDSD must return a result
              to the caller. SCCPDSD returns the number (relative to 0)
              of datasets concatenated within the DDname.


 Notes:       Choice of a technique to manage the 'data stack' is a
              subjective matter. SCCPDSD makes no choice. If the REXX
              program requires stack isolation, the programmer must
              use an appropriate technique.
./ ADD NAME=ID       0102-98050-98050-1606-00049-00046-00000-PST0705
         MACRO
&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY
         LCLC  &U,&LBL
.*
.* Stelco macro used to:
.*    - generate the CSECT statement.
.*    - generate the USING, AMODE and RMODE statements for the CSECT.
.*    - generate an eye-catcher and date/time stamp (28 bytes total).
.*      (The values for date and time are the time of the Assembly.)
.*
.* The default for the USING statement is (register) 15.
.* Other defaults are as per the prototype above.
.*
.* If the CSECT requires multiple base registers, their specification
.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)
.*
.* This macro can also be used to generate only the eye-catcher and
.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO
.*
.* -----------------------Modification History-------------------------
.* 98-02-19 change from &SYSDATE to &SYSDATC
.*
&U       SETC  '15'
&LBL     SETC  ' '
         AIF   (K'&LABEL EQ 0).LBLSET
&LBL     SETC  '&LABEL'
.LBLSET  ANOP
         AIF   (T'&USING EQ 'O').USET
         AIF   ('&USING'(1,1) NE '(').ONEUSE
&U       SETC  '&USING'(2,K'&USING-2)
         AGO   .USET
.ONEUSE  ANOP
&U       SETC  '&USING'
.USET    ANOP
         AIF   ('&CSECT' EQ 'YES').CSECT
&LBL     DS    0H
         B     *+32
         AGO   .STAMP
.CSECT   ANOP
&LBL     CSECT
&LBL     AMODE &AMODE
&LBL     RMODE &RMODE
         USING &LABEL,&U
         BC    15,32(,15)
.STAMP   ANOP
         DS    CL4
         DC    CL8'&LBL'
         DC    CL16'&SYSDATC &SYSTIME'
         MEND
./ ADD NAME=SCCPDSD  0139-95181-01019-1445-00456-00355-00000-PST0705
PDSD     TITLE            '<< REXX - Get PDS directory entry           X
                                                      Documentation >>'
* Name:        SCCPDSD
*
* Purpose:     Select the directory entries of a specified
*              partitioned dataset via (Assembler) subroutine STSS383.
*
* Environment: REXX subroutine/function for Address TSO or MVS
*
* Features:    STSS383 supports 'wildcard' selection criteria for the
*              directory entries via (Assembler) subroutine SCCWC001
*
*              The caller access the directory entries through either:
*                 - a "stemmed" variable
*                 - the "data stack"
*
* Parameters:  1. The DDNAME which refers to the partitioned dataset.
*
*              2. The member selection criteria. This parameter
*                 supports the 'wildcard' values of '*' (asterisk)
*                 and '%' (percent sign). Refer to subroutine
*                 SCCWC001 for more information on these wild
*                 cards.
*
*              3. (optional) The name of the stem variable which
*                 will be assigned the values from the record. If the
*                 caller does not delimit the stem with a period,
*                 one is generated.
*
*                 The REXX programmer should ensure that the value
*                 specified for the call is enclosed in quotes.
*
*                 stem.0 is assigned the value of the number of
*                 records read.
*
*                 If parameter 3 is not specified or specified as null,
*                 SCCPDSD places the records in the data stack.
* Notes:
*
*    There are mutually exclusive techniques to handle the data stack.
*    Since the choice of a technique is subjective, SCCPDSD makes no
*    choice. If stack isolation is required, an appropriate technique
*    is the responsibilty of the callin program.
*
         TITLE            '<< REXX - Get PDS directory entry           X
                                                     System Linkage >>'
SCCPDSD  ID    R12
         SPACE 2
         STM   R14,R12,12(R13)
         LR    R12,R15
         ST    R13,SAVEAREA+4
         LA    R15,SAVEAREA
         ST    R15,8(,R13)
         LR    R13,R15
         XC    RC,RC
         B     MAINLINE
         SPACE 3
RC       DS    0F
         DS    AL1
RC1      DS    AL1
RC2      DS    AL1
RC3      DS    AL1
         SPACE 1
SAVEAREA DS    18F
         SPACE 3
RTNXT    DS    0H
         L     R13,SAVEAREA+4
         XC    8(4,R13),8(R13)
         XC    16(4,R13),16(R13)   R15 (return code) always
         LM    R14,R12,12(R13)        get set to zero.
         BR    R14
         TITLE            '<< REXX - Get PDS directory entry           X
                                                Parse the Arguments >>'
MAINLINE DS    0H
         USING EFPL,R1
         USING ENVBLOCK,R8
         USING IRXEXTE,R9
         USING EVALBLOCK,R11
         USING SHVBLOCK,R14
         LR    R8,R0               Address the environment block.
         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.
         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK.
         L     R11,0(,R11)
         LM    R14,R0,SET_REGS-12
         STM   R14,R0,SET_REGS
         MVI   DDNAME,C' '
         MVC   DDNAME+1(L'DDNAME+L'MEM_NAME-1),DDNAME
         XC    SHVNAMA-SHVBLOCK+@SHV,SHVNAMA-SHVBLOCK+@SHV
         MVI   TRTABLE-1,X'FF'     Pre-set table value.
         NI    PLIST383,X'7F'      More than one parm for STSS383.
*        WTO   'SCCPDSD started.'
         BAL   R14,STRIP           Strip out arg(1).
         B     MISSING_DD          Arg(1) not specified.
         LA    R0,7                Maximum length.
         CR    R15,R0              Length(arg(1)) > maximum ?
         BNH   *+6                    -no -
         LR    R15,R0                 -yes-   Use maximum
         EX    R15,MVC_DD          Pick-up the DDname.
         SPACE 1
         BAL   R14,STRIP           Strip out arg(2).
         B     MISSING_MEM         Arg(2) not specified
         LA    R0,7                Maximum length.
         CR    R15,R0              Length(arg(2)) > maximum ?
         BNH   *+6                    -no -
         LR    R15,R0                 -yes-   Use maximum
         EX    R15,MVC_MEM         Pick-up the member name.
         LA    R15,1(,R15)
         ST    R15,SELECT_LEN
         MVC   NON_WILD,MEM_NAME
         TR    NON_WILD,NON_WILD_TR
         BAL   R14,STRIP           Strip out arg(3).
         B     MISSING_STEM        Arg(3) not specified
         LA    R0,244              Maximum length of variable stem.
         SR    R0,R15              Calculate
         LA    R2,VAR_NAME            address where
         AR    R2,R0                     stem will be stored.
         CLI   0(R4),C'.'          Does stem end with period?
         BE    *+10                   -yes-
         BCTR  R2,0                   -no -   adjust address and
         MVI   TAIL-1,C'.'                       provide the period.
         EX    R15,MVC_STEM        Pick-up the stem name.
         ST    R2,SHVNAMA-SHVBLOCK+@SHV   Variable name addr into SHVB.
         LA    R0,TAIL+1           Include one digit of 'tail'
         SR    R0,R2                  in the qualified
         ST    R0,SHVNAML-SHVBLOCK+@SHV  variable name length.
         SPACE 1
MISSING_STEM   DS    0H
         TITLE            '<< REXX - Get PDS directory entry           X
                      Call STSS383 and determine method of disposal >>'
         XC    ADRCTRY,ADRCTRY     Pre-set STSS383's result to zero.
         LA    R1,PLIST383         Parameter list.
         L     R15,VSTSS383        Entry point address.
         BALR  R14,R15             Call.
         L     R10,ADRCTRY         Address STSS383's result.
         LTR   R10,R10             Did STSS383 set the address?
         BZ    @383_FAILED            -no -
         USING DRCTPREF,R10
         LH    R0,DRCTCON          Number of concatenation levels
         CVD   R0,DBLWD               into
         OI    DBLWD+7,X'0F'             ebcdic
         UNPK  EVALBLOCK_EVDATA(3),DBLWD+6(2)  format.
         LA    R0,3                Let
         ST    R0,EVALBLOCK_EVLEN     REXX know the length of data.
         DROP  R11                 Done addressing EVALBLOCK.
         LH    R11,DRCTCNT         Get the number of directory entries.
         LTR   R11,R11             Empty PDS?
         BZ    DO_STEM0               -yes-
         LA    R10,DRCTNTRY        Address the first directory entry.
         B     MATCH_ENTRY
         DROP  R10
         USING DRCTNTRY,R10
NEXT_ENTRY DS  0H
         BCT   R11,*+8
         B     DO_STEM0
         SR    R1,R1               Clear a register to
         IC    R1,MEMLEN              pick-up number of member halfwd.
         LA    R0,31               B'00011111' zero out bits 0,1,2
         NR    R1,R0                  of byte 3 within register.
         SLL   R1,1                Half words to bytes.
         LA    R10,14(R1,R10)      Address the next entry.
MATCH_ENTRY DS 0H
         ST    R10,PLIST_WC001+8   Address of SCCWC001 'target'.
         LA    R1,PLIST_WC001      Call
         L     R15,VWC001             ...
         BALR  R14,R15                   SCCWC001
         BE    STEM_OR_STACK       Matched.
         CLC   NON_WILD,MEMNAME    Beyond matching?
         BNL   NEXT_ENTRY             -not yet-
DO_STEM0 DS    0H
*        WTO   'SCCPDSD after last CALL SCCWC001.'
         LA    R1,PLIST383
         OI    PLIST383,X'80'      One parm for STSS383.
         L     R15,VSTSS383        Entry point address.
         BALR  R14,R15             Call to free areas.
*        WTO   'SCCPDSD after last CALL STSS383.'
         L     R2,SHVNAMA-SHVBLOCK+@SHV  Address of variable name.
         LTR   R2,R2               Did caller specify a stem variable?
         BZ    RTNXT                  -no -   Go stack the entries.
         MVI   TAIL,C'0'           Will be setting stem.0
         LA    R0,TAIL+1           Calculate
         SR    R0,R2                  length of variable name and
         ST    R0,SHVNAML-SHVBLOCK+@SHV  tell EXCOM about it.
         L     R0,SET_REGS         Get the record count
         CVD   R0,DBLWD               into a
         UNPK  NON_WILD(5),DBLWD+5(3)    ebcidic
         OI    NON_WILD+4,X'F0'             format.
         LA    R1,NON_WILD         Leftmost byte of variable value.
         LA    R2,4                Maximum loop counter.
         LA    R15,*+4             Top-of-loop address.
         CLI   0(R1),C'0'          Insignificant zero?
         BNE   *+10                   -no -
         LA    R1,1(,R1)           Next byte.
         BCTR  R2,R15              Count and loop.
         SPACE 1
         LA    R2,1(,R2)           Residual of loop-counter plus 1
         ST    R2,SHVVALL-SHVBLOCK+@SHV equals the length of the value.
         ST    R1,SHVVALA-SHVBLOCK+@SHV  EXCOM finds the value there.
         L     R15,IRXEXCOM        Get routine's address from vector.
         LA    R0,ENVBLOCK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM
         BALR  R14,R15
         B     RTNXT
STEM_OR_STACK  DS    0H
         SR    R1,R1               Clear a register to
         IC    R1,MEMLEN              pick-up number of member halfwd.
         LA    R0,31               B'00011111' zero out bits 0,1,2
         NR    R1,R0                  of byte 3 within register.
         SLL   R1,1                Half words to bytes
         LA    R1,14(,R1)             plus minimum length.
         ST    R1,SHVVALL-SHVBLOCK+@SHV
         ST    R10,SHVVALA-SHVBLOCK+@SHV
         AR    R10,R1
         L     R2,SHVNAMA-SHVBLOCK+@SHV  Address of variable name.
         LTR   R2,R2               Did caller specify a stem variable?
         BZ    STACK                  -no -   Go stack the entries.
         TITLE            '<< REXX - Get PDS directory entry           X
                             Place record into the stemmed variable >>'
         LM    R2,R4,SET_REGS
         LA    R2,1(,R2)           Count the entries and
         ST    R2,SET_REGS            save the count.
         CVD   R2,DBLWD            Covert the count
         UNPK  TAIL,DBLWD+5(3)        to ebcdic
         OI    TAIL+4,X'F0'              format.
         BCTR  R3,R4               Branch unless count was 10, 100 etc.
         L     R3,SHVNAML-SHVBLOCK+@SHV  Length of tail
         LA    R3,1(,R3)                    just increased by one
         ST    R3,SHVNAML-SHVBLOCK+@SHV        so save.
         CLI   TAIL,C'1'           Just counted 10,000?
         BE    SET@10000              -yes-
         CLI   TAIL+1,C'1'         Just counted 1,000?
         BE    SET@1000               -yes-
         CLI   TAIL+2,C'1'         Just counted 100?
         BE    SET@100                -yes-
         LA    R3,90               At 10 now, re-set counter @ 90
         LA    R4,*+8              Re-set address for left adjust move
         ST    R4,SET_REGS+8          and save it.
         MVC   TAIL(2),TAIL+3      Left adjust the tail to stem.
         B     CALL_EXCOM          Ready for IRXEXCOM.
SET@100  DS    0H                  At 100 now,
         LA    R3,900                 re-set counter @ 900
         LA    R4,*+8              Re-set address for left adjust move
         ST    R4,SET_REGS+8          and save it.
         MVC   TAIL(3),TAIL+2      Left adjust the tail to stem.
         B     CALL_EXCOM          Ready for IRXEXCOM.
SET@1000 DS    0H                  At 1,000 now,
         L     R3,=A(9000)            re-set counter @ 9000
         LA    R4,*+8              Re-set address for left adjust move
         ST    R4,SET_REGS+8          and save it.
         MVC   TAIL(4),TAIL+1      Left adjust the tail to stem.
         B     CALL_EXCOM          Ready for IRXEXCOM.
SET@10000 DS   0H                  At 10,000 now,
         L     R3,=A(90000)           re-set counter @ 90000
         LA    R4,CALL_EXCOM       Re-set address for no adjust move
         ST    R4,SET_REGS+8          and save it.
         B     CALL_EXCOM          Ready for IRXEXCOM.
SET@1    DS    0H
         MVC   TAIL(1),TAIL+4
         TITLE            '<< REXX - Get PDS directory entry           X
                Assign the value from the record to a REXX variable >>'
CALL_EXCOM  DS  0H
         ST    R3,SET_REGS+4       Save the loop counter.
*
* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
CALL_EXCOM@    DS  0H
         L     R15,IRXEXCOM        Get routine's address from vector.
         LA    R0,ENVBLOCK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM
         BALR  R14,R15
         BCT   R11,MATCH_ENTRY
         B     DO_STEM0
         SPACE 1
PLIST_EXCOM DC A(EXCOM_LIT,0,0)
         DC    A(@SHV+X'80000000')
         SPACE 1
@SHV     DS    0A
         DC    2A(0)
         DC    C'S'
         DS    XL3'000000'
         DC    5A(0)
         SPACE 1
EXCOM_LIT DC   CL8'IRXEXCOM'
         TITLE            '<< REXX - Get PDS directory entry           X
                                   Put the record on the data stack >>'
*
* Refer to the IRXSTK   routine; pages 485-490 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
STK_FUNC DC    CL8'QUEUE   '
STK_PLIST  DC  A(STK_FUNC)
         DC    A(SHVVALA-SHVBLOCK+@SHV)
         DC    A(SHVVALL-SHVBLOCK+@SHV)
         DC    A(RC+X'80000000')
STACK    DS    0H
         LA    R1,STK_PLIST
         LA    R0,ENVBLOCK
         L     R15,IRXSTK
         BALR  R14,R15
         BCT   R11,MATCH_ENTRY
         B     DO_STEM0
         TITLE            '<< REXX - Read a PDS member                 X
                     Subroutine to Strip Leading && Trailing Blanks >>'
         DROP  R10
         USING ARGTABLE_ENTRY,R10
* Registers upon entry
*    R10 ==> argument table entry
*    R14 ==> exit address when agrument is null
*    R14+4=> normal exit
*
* Registers upon exit
*    R10 ==> next argument table entry.
*    R2    = 0 (zero)
*    R3  ==> leftmost non-blank byte of argument
*    R4  ==> rightmost non-blank byte of argument
*    R15   = R4 - R3 (length of argument minus 1)
         SPACE 2
TRT3     TRT   0(0,R3),TRTABLE
HEXFF    DC    X'FFFFFFFFFFFFFFFF'
         DS    XL1
TRTABLE  DS    XL256
         SPACE 2
STRIP    DS    0H
         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?
         BER   R14                              -no -
         L     R15,ARGTABLE_ARGSTRING_LENGTH
         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.
         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.
         SPACE 1
         LTR   R15,R15             Does the argument have any length?
         BZR   R14                    -NO - take abnormal exit.
         LA    R4,0(R15,R3)        Point just beyond ARG.
         MVC   TRTABLE,TRTABLE-1   Set to
         MVI   TRTABLE+C' ',X'00'     bypass blanks.
         BCTR  R15,0               Set length for TRT instruction.
         EX    R15,TRT3            Skip to non-blank.
         BZR   R14                 When all blank.
         LR    R3,R1               Re-set starting address.
STRIP@R  DS    0H
         BCTR  R4,0                Backpedal 1 byte.
         CLI   0(R4),X'40'         (still) at a blanK?
         BNE   STRIPPED               -no -
         CR    R4,R3                  -yes-  More to inspect?
         BH    STRIP@R                          -yes-
STRIPPED DS    0H
         LR    R15,R4              Calculate
         SR    R15,R3                 length of ARG - 1.
         SR    R2,R2               Pre-clear R2 for TRT
         XC    TRTABLE,TRTABLE     Clear translate table.
         BC    15,4(,R14)          Take normal exit.
         TITLE            '<< REXX - Get PDS directory entry           X
                                                   Error Conditions >>'
*
* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
SAY_LIT        DC    CL8'WRITE   '
SAY_BUFF       DS    A
SAY_LEN        DS    F
SAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')
@383_MSG DC    C'Directory read (STSS383) failure.'
MISSING_DD_MSG DC    C'First argument (DDNAME) missing.'
MISSING_MEM_MSG DC   C'Second argument (member selection criteria) missi
               ing.'
@383_FAILED    DS    0H
         LA    R15,@383_MSG
         LA    R0,L'@383_MSG
         B     SAY_CALL
MISSING_DD     DS    0H
         LA    R15,MISSING_DD_MSG
         LA    R0,L'MISSING_DD_MSG
         B     SAY_CALL
MISSING_MEM    DS    0H
         LA    R15,MISSING_MEM_MSG
         LA    R0,L'MISSING_MEM_MSG
         B     SAY_CALL
SAY_CALL DS    0H
         ST    R15,SAY_BUFF
         ST    R0,SAY_LEN
         LA    R1,SAY_PLIST
         LA    R0,ENVBLOCK
         L     R15,IRXSAY
         BALR  R14,R15
         L     R13,SAVEAREA+4
         XC    8(4,R13),8(R13)
         LM    R14,R12,12(R13)
         LA    R15,40
         BR    R14
         TITLE            '<< REXX - Get PDS directory entry           X
                                              Global Data Constants >>'
         SPACE 2
DBLWD    DS    D
         SPACE 2
         DC    A(0,10,SET@1)
SET_REGS DS    3A
         SPACE 1
VSTSS383 DC    V(STSS383)
VWC001   DC    V(SCCWC001)
         SPACE 1
F8       DC    F'8'
SELECT_LEN DS  F
         SPACE 1
PLIST383 DC    A(DDNAME,ADRCTRY+X'80000000')
PLIST_WC001 DC    A(MEM_NAME,SELECT_LEN,0,F8+X'80000000')
DDNAME   DC    CL8' '
MEM_NAME DC    CL8' '
NON_WILD DC    CL8' '
ADRCTRY  DS    F
MVC_DD   MVC   DDNAME(0),0(R3)
MVC_MEM  MVC   MEM_NAME(0),0(R3)
MVC_STEM MVC   0(0,R2),0(R3)
         SPACE 2
NON_WILD_TR DC 256AL1(*-NON_WILD_TR)
         ORG   NON_WILD_TR+C'*'
         DC    X'FF'
         ORG   NON_WILD_TR+C'%'
         DC    X'FF'
         ORG
         SPACE 2
VAR_NAME DS    0CL250
         DS    CL245
TAIL     DS    CL5
         SPACE 2
         LTORG
         TITLE            '<< REXX - Get PDS directory entry           X
                                                 DSECTs and EQUates >>'
         YREGS
         SPACE 2
       IRXENVB
         SPACE 2
       IRXEXTE
         SPACE 2
       IRXSHVB
         SPACE 2
       IRXEFPL
         SPACE 2
      IRXARGTB
         SPACE 2
      IRXEVALB
         SPACE 2
DRCT00D  DSECT
DRCTPREF DS   0D        Prefix area double word aligned.
DRCTSIZ  DS   F         Size of table (in bytes).
DRCTCNT  DS   H         Number of directory entries.
DRCTCON  DS   H         Concatenation levels.
*                End of prefix area
DRCTNTRY DS   0CL14     (Note minimum size).
MEMNAME  DS   CL8       Member name.
MEMTTR   DS   XL3       Member "ttr" location.
MEMCON   DS   XL1       Member concatenation level.
         DS   XL1       Reserved.
MEMLEN   DS   XL1       Number of user halfwords
MEMALIAS EQU  X'80'     Mask for an ALIAS designation.
MEMTTRNS EQU  X'60'     Mask for # of "ttrn" halfwords.
MEMHALF  DS   0H        Member "user data".
         END  SCCPDSD
./ ADD NAME=SCCWC001 0108-95180-95229-1033-00139-00122-00000-PST0705
* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *
*
* Program name :  SCCWC001
*
* Function:       Determine if the selection parameter (which may
*                 contain 'wildcard' specifications of * and %) is
*                 matched to the target parameter.
*
*                 A wildcard value of percent sign (or x'FF') means
*                 the corresponding column in the target must exist.
*                 A wildcard value of asterisk will match to any
*                 string of any length (including 0) in the target.
*
*                 Multiple wildcard specifications are valid.
*
* Parameters:  1. The 'selection' field. A string of characters which
*                 may contain 'wildcard' values as described above.
*                 All non-wildcard values are compared for an exact
*                 match against the target parameter.
*
*              2. Fullword field whose hexadecimal value is the
*                 length of parameter 1.
*
*              3. The 'target' field. This (sub)field is what the
*                 'selection' parameter is attempting to match.
*
*              4. Fullword field whose hexadecimal value is the
*                 length of parameter 3.
*
* Output:      SCCWC001 produces no output parameter. It sets the
*              condition code to zero if a match is made and sets the
*              condition code to other than zero if no match is made.
*              (No meaning other than 'not equal' should be derived
*              from condition code settings of 1 or 2; condition code
*              3 should never be set.)
*
* Updates:
*     Jun. 1995    - R. Ryerse. Original composition.
*
* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *
SCCWC001 ID    R12
         STM   R14,R12,12(R13)
         LR    R12,R15
         B     START
FORCE_EQUAL DS 0H
         SR    R0,R0
         B     RTNXT
FORCE_LOW  DS  0H
         CLI   SCCWC001,X'FF'
         B     RTNXT
FORCE_HIGH  DS 0H
         CLI   SCCWC001,X'00'
RTNXT    DS    0H
         LA    R0,0                  Need a convenient zero to
         ST    R0,16(,R13)              set R15 to zero.
         LM    R14,R12,12(R13)       Re-set callers registers.
         BR    R14                   Return to caller.
         SPACE 3
START    DS    0H
         XC    A_STAR,A_STAR         We have no asterisk (yet).
         LM    R3,R6,0(R1)           Pick-up parameter addresses.
         L     SELECT_COUNT,0(,R4)   Get length(select).
         L     TARGET_COUNT,0(,R6)   Get length(target).
         LA    R1,0(TARGET_COUNT,TARGET)
         LA    R7,*+4
         BCTR  R1,0
         CLI   0(R1),C' '
         BNE   *+6
         BCTR  TARGET_COUNT,R7
         LA    R7,LOOP
LOOP     DS    0H            The major loop.
         CLI   0(SELECT),C'*'        Match everything?
         BNE   NOT_ASTERISK             -no -
         LA    R7,LOOP@                 -yes-   Switch to minor loop
         B     COUNT_SELECT                        and continue.
NOT_ASTERISK   DS    0H
         CLI   0(SELECT),C'%'        Match any character?
         BE    COUNT_TARGET             -yes-
         CLC   0(1,SELECT),0(TARGET) Matched?
         BNE   RE_LOOP                  -no - double check needed.
COUNT_TARGET   DS    0H
         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.
         BCT   TARGET_COUNT,COUNT_SELECT  Count and continue.
         B     END_OF_TARGET         'Target' is exhausted.
COUNT_SELECT   DS    0H
         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.
         BCTR  SELECT_COUNT,R7       Count the select and loop.
         SPACE 2
* The 'select' field is exhausted but 'target' is not.
         LA    R0,LOOP@              Was last 'select' byte
         CR    R0,R7                    an asterisk?
         BE    RTNXT                       -yes-   We have a match
RE_LOOP  DS    0H
         LM    SELECT,TARGET_COUNT,A_STAR
         LTR   SELECT,SELECT         Was there a previous asterisk?
         BZ    FORCE_LOW                -no -
         LA    TARGET,1(,TARGET)     Post asterisk matched plus one
         BCT   TARGET_COUNT,LOOP@@      and length minus one.
         B     FORCE_LOW             Target went exhausted.
END_OF_TARGET  DS    0H
         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.
         BCT   SELECT_COUNT,*+8      Count 'select'.
         B     FORCE_EQUAL           'Select' equally exhausted.
         CLI   0(SELECT),C'*'        Afterthought '*'
         BE    END_OF_TARGET            -yes-   Keep checking.
         B     FORCE_HIGH               -no -   No match.
         EJECT
LOOP@    DS    0H            After '*' in select.
         CLI   0(SELECT),C'*'        Another asterisk?
         BE    COUNT_SELECT@            -yes-   Really has no meaning.
         CLI   0(SELECT),C'%'        Looking for any character?
         BNE   LOOP@@                   -no -
         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.
         BCT   TARGET_COUNT,COUNT_SELECT@ Decrement 'target' count.
         B     END_OF_TARGET@        'Target' is exhausted.
COUNT_SELECT@  DS    0H
         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.
         BCTR  SELECT_COUNT,R7       Count the select and loop.
         B     FORCE_EQUAL           'Select' is exhausted.
END_OF_TARGET@ DS    0H
         BCT   SELECT_COUNT,FORCE_LOW Count 'select'. No match if more.
         B     FORCE_EQUAL           'Select' equally exhausted.
LOOP@@   DS    0H
         LA    R7,LOOP               Revert to major loop.
         STM   SELECT,TARGET_COUNT,A_STAR
         CLC   0(1,SELECT),0(TARGET) Matched?
         BE    COUNT_TARGET             -yes-   Jump into major loop.
         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.
         BCT   TARGET_COUNT,LOOP@@+4 Decrement 'target' count. Loop.
         B     RTNXT                 LOOP@@+8 has set condition code.
         SPACE 3
         DS    0D
A_STAR   DS    XL16
         YREGS
SELECT         EQU   R3
SELECT_COUNT   EQU   R4
TARGET         EQU   R5
TARGET_COUNT   EQU   R6
         END   SCCWC001
./ ADD NAME=STSS383  0131-95310-98218-0839-00577-00710-00000-PST0705
SS383    TITLE                     '<< Load/search a PDS directory     >
                                                      Documentation >>'
* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *
*
* Program name :  STSS383
*
* Function:       Build and/or search an in-core directory of a
*                 specified partitioned data set.
*
* Parameters:     Be aware that the number of parameters passed to this
*                 routine determines the funtion to be performed
*
*                 When there are no parameters, STSS383 releases all
*                 the tables it has built.
*
*                 When there is one parameter, STSS383 releases the
*                 the table for the specified DDNAME.
*
*                 When there are two parameters, STSS383 returns the
*                 address of the table for the specified DDNAME.
*
*                 When there are three parameters, STSS383 matches
*                 the specified member name and provides
*                 addressability to the directory entry of the latest
*                 version of that memeber.
*
*   1. In all cases (except when there are no parameters) the 1st
*      parameter is an eight byte field containing the value of the
*      DDNAME which STSS383 must act upon.
*
*   2. In the case where there are two parameters, the 2nd parameter is
*      a fullword "cell" where STSS383 puts the address of the
*      structure mapped as follows:
*
*         DRCT00D  DSECT
*         DRCTPREF DS   0D        Prefix area double word aligned.
*         DRCTSIZ  DS   F         Size of table (in bytes).
*         DRCTCNT  DS   H         Number of directory entries.
*         DRCTCON  DS   H         Concatenation levels.
*         *                End of prefix area
*         DRCTNTRY DS   0CL14     (Note minimum size).
*         MEMNAME  DS   CL8       Member name.
*         MEMTTR   DS   XL3       Member "ttr" location.
*         MEMCON   DS   XL1       Member concatenation level.
*                  DS   XL1       Reserved.
*         MEMLEN   DS   XL1       Number of user halfwords
*         MEMALIAS EQU  X'80'     Mask for an ALIAS designation.
*         MEMTTRNS EQU  X'60'     Mask for # of "ttrn" halfwords.
*         MEMHALF  DS   0H        Member "user data".
*
*      Note that the mapping above shows the table "prefix" area
*      and one memeber.
*
*      In the case where there are three parameters, the 2nd parameter
*      is an eight byte field containing the member name to be matched.
         EJECT
*   3. The 3rd parameter is a fullword where STSS383 places the
*      address of the entry for the requested member.
*      Zero signifies a "not-found".
*
* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *
         TITLE                     '<< load/search a pds directory     >
                                            initialization per call >>'
STSS383  ID    R12,AMODE=31,RMODE=24
         SPACE 2
         PRINT NOGEN
         USING IHADCB,R11
         STM   R14,R12,12(R13)     Save the callers registers
         LR    R12,R15             Establish my base register.
         LA    R15,SAVEAREA        Add
         ST    R13,SAVEAREA+4         myself to the
         ST    R15,8(,R13)               save area chain
         LR    R13,R15             Finally linkup savearea chain.
         ST    R1,APARMS           Save parameter list address.
         LA    R11,DRCTDCB
         MVI   COBOLSW,X'00'       Indicate non-COBOL caller.
         XC    RC,RC               Pre-clear return code
         XC    HCONCAT,HCONCAT        concatenation level
         XC    ALLEN,ALLEN               and total length.
         LTR   R1,R1               Any parameters?
         BZ    FREEALL                -no -  Go free acquired areas.
         TM    0(R1),X'80'         Only one parameter?
         BO    FREEONE                -yes-  Go free acquired area.
         TM    4(R1),X'80'         Did I get 2 parameters?
         BO    *+12                   -yes-
         TM    8(R1),X'80'         Did I get 3 parameters?
         BZ    BADPARMS              -no - Something wrong here.
         L     R3,0(,R1)           Addressablity to parameters.
         MVC   DCBDDNAM,0(R3)
         LA    R5,DDTBL-DDNTRY     Pre-set for table search.
NXTDD    DS    0H
         LA    R5,DDNTRY(0,R5)     Point to next table entry.
         CLC   BLANK8,0(R5)        At end of active entries?
         BE    SETDD                    -yes-
         CLC   DCBDDNAM,0(R5)
         BE    PARMOUT
         C     R5,=A(DDLAST)       Any more entries?
         BL    NXTDD                  -yes-  Go inspect them.
         B     XTBL                   -no -  Abort.
SETDD    DS    0H
         MVC   0(8,R5),0(R3)       Save the DDNAME in the table entry.
         ST    R5,ADDNTRY          Save address of this entry.
         OPEN  ((R11)),MODE=31
         LA    R0,ATBL0            The first entry
         ST    R0,AATBL               is the current entry.
         L     R0,GETMAIN_AVAIL    64K minus prefix (8) and 1 minimum
         ST    R0,TBLEN               entry is the length available.
         L     R0,GETMAIN_SIZE     Want 64K of virtual storage.
       GETMAIN R,LV=(0)
         MVC   0(4,R1),GETMAIN_SIZE
         L     R5,ADDNTRY          Point to my table entry so I can
         ST    R1,8(0,R5)             save the storage address
         ST    R1,ATBL0                  also at index entry.
         OI    ATBL0,X'80'         Say GETMAIN'd area.
         LA    R1,8(0,R1)          Point to the 1st member area and
         ST    R1,ATBLNTRY               1st member address.
         SR    R8,R8               Initialize member counter.
         TITLE                     '<< Load/search a pds directory     >
                                          mainline (including read) >>'
READDRCT DS    0H
         AMODE24
         PRINT   GEN
         GET   (R11)
         AMODE31
         MVC   DRCTBLK,0(R1)
         BAL   R9,DEBLOCK          De-block a directory block.
         CLC   =XL8'FFFFFFFFFFFFFFFF',0(R7)
         BNE   READDRCT            More directory blocks to come.
         FEOV  (R11)               Get next DD in the concatenation.
         PRINT NOGEN
         LH    R9,HCONCAT          Next concatenation exists so
         LA    R9,1(,R9)              count 1 more and
         STH   R9,HCONCAT                save the sum.
         BAL   R9,NEXT_INDEX       I'll need another sector.
         B     READDRCT            Go for more.
EODRCT   DS    0H
         CLOSE ((R11)),MODE=31
         MVC   DRCTDCB(DCB_LEN),A_DCB
         BAL   R9,TBLOUT           Format into one table.
PARMOUT  DS    0H
         L     R5,ADDNTRY          Pickup my entry for this DD and
         L     R2,8(,R5)              get the table address for it.
         L     R1,APARMS           Restore my parameter list address.
         TM    4(R1),X'80'         Two parameters?
         BZ    SEARCH0                -no -  Must be three parms.
         L     R3,4(,R1)           Get the address of the 2nd parm.
         ST    R2,0(,R3)           Give the caller the table address.
         B     RTNXT               All done.
SEARCH0  DS    0H
         BAL   R9,SEARCH           Search for a member.
RTNXT    DS    0H
         L     R15,RC              Set the return code.
         L     R13,SAVEAREA+4      Get the caller's savearea
         L     R14,12(,R13)        Get the caller's return address.
         LM    R0,R12,20(R13)      Restore the caller's registers
         XC    8(4,R13),8(R13)     Take a link off the savearea chain.
         BR    R14                 Return to the caller.
         TITLE                     '<< Load/search a pds directory     >
                                         de-block record into table >>'
USERIN   MVC   14(0,R4),12(R7)
DEBLOCK9 DS    F
         SPACE 1
DEBLOCK  DS    0H
         ST    R9,DEBLOCK9         Save the BAL return address.
         LH    R2,DRCTBLK          Get the length
         BCTR  R2,0                   of data
         BCTR  R2,0                       within the block.
         LA    R3,42(0,R2)         Do I have enough
         C     R3,TBLEN               room in the table?
         BL    *+8                       -yes-
         BAL   R9,NEWSPAC                -no -  Get some more space.
         SR    R3,R3               Pre-clear a work register.
         LM    R4,R7,ATBLNTRY      Get various pointers.
DEBLOCK1 DS    0H
         CLC   =XL8'FFFFFFFFFFFFFFFF',0(R7)
         BE    DEBLOCK8            Block is finished.
         LA    R8,1(0,R8)          Increment the memeber counter.
         IC    R3,11(R7)           Get number of user halfwords
         N     R3,=F'31'              voiding the high order 3 bits.
         SLL   R3,1                Halfword to bytes and
         LA    R3,14(0,R3)            include the overhead.
         SR    R6,R3               Decrement table length.
         AR    R5,R3               Increment total length.
         MVC   0(11,R4),0(R7)      Get the member name and TTR.
         MVC   13(1,R4),11(R7)     Get the number of user halfwords.
         MVC   11(1,R4),CONCAT     Get the concatenation level and
         MVI   12(R4),X'00'           set a convenient halfword.
         SH    R3,=H'15'           Decrement by overhead length + 1.
         BNP   DEBLOCK2            There is nothing left.
         EX    R3,USERIN           Get the user data.
DEBLOCK2 DS    0H
         LA    R3,13(,R3)          Restore the member length.
         AR    R7,R3               Point to next source member
         LA    R4,2(R3,R4)         Point to next target member.
         SR    R2,R3               Decrement the block residual size.
         BP    DEBLOCK1            There is still more to come.
DEBLOCK8 DS    0H
         STM   R4,R6,ATBLNTRY      Replace all that good stuff.
         L     R9,DEBLOCK9         Get the return address.
         BR    R9                  Exit this BAL procedure.
         TITLE                     '<< Load/search a pds directory     >
                   Switch to a new sector  /  Allocate more storage >>'
GETMAIN_SIZE   DC  A(GETMAIN_VALUE)
GETMAIN_AVAIL  DC  A(AVAIL_VALUE)
TBLNTRYS EQU   64                  Maximum number of tables.
         SPACE 1
AATBL    DC    A(ATBL0)            Current entry of table below.
ATBL0    DS    (TBLNTRYS-1)F
ATBLF    DS    F
         SPACE 1
NEXT_INDEX  DS 0H
         L     R3,AATBL            Already at
         C     R3,=A(ATBLF)           last cell?
         BNL   BADTBL                    -yes-   down the tubes.
         LA    R3,4(0,R3)                -no - point to next cell and
         ST    R3,AATBL                           save the cell address
         L     R4,ATBLNTRY         Point no temp table slot.
         MVI   0(R4),X'FF'         Fill slot
         MVC   1(10,R4),0(R4)         with a
         MVC   11(1,R4),CONCAT           high-value
         XC    12(2,R4),12(R4)              entry.
         LA    R4,14(0,R4)         Point beyond dummy slot in temp tbl.
         ST    R4,ATBLNTRY         Save the address for later ntrys.
         ST    R4,0(0,R3)          Fill cell for next temp table.
         L     R6,TBLEN            Decrement
         S     R6,=F'14'              available storage
         ST    R6,TBLEN                  and save it.
         BR    R9                  Exit via bal register.
         SPACE 3
NEWSPAC0 DS    10F
         SPACE 1
NEWSPAC  DS    0H
         STM   R0,R9,NEWSPAC0      Save all those values.
         BAL   R9,NEXT_INDEX       Allocate a new table entry.
         MVC   TBLEN,GETMAIN_AVAIL Set the 'storage available'.
         L     R0,GETMAIN_SIZE     64K.
       GETMAIN R,LV=(0)
         MVC   0(4,R1),GETMAIN_SIZE
         L     R9,AATBL            Point to index entry.
         ST    R1,0(0,R9)          The index knows where to save data.
         OI    0(R9),X'80'         Set GETMAIN'd indicator.
         LA    R1,8(,R1)           Point beyond the prefix area.
         ST    R1,ATBLNTRY         Save the virtual storage address.
         LM    R0,R9,NEWSPAC0      Restore all those registers.
         BR    R9                  Exit via BAL register.
         TITLE                     '<< Load/search a pds directory     >
                                                 Load callers table >>'
TBLOUT   DS    0H
         L     R3,ADDNTRY          Get address for the DD table entry.
         LA    R2,ATBL0            Is the first index
         C     R2,AATBL               the current index?
         BNE   TBLOUT1                   -no -
         L     R2,ATBL0            Get the primary table address
         LA    R2,0(,R2)           Clear the high order bit.
         ST    R2,8(0,R3)          Put address into DDtable entry.
         STH   R8,4(R2)            Put the memeber count, and
         MVC   6(2,R2),HCONCAT        the concatenation level.
         BR    R9                  That's all there is to it.
TBLOUT1  DS    0H
         L     R2,ATBLNTRY
         MVI   0(R2),X'FF'         Set
         MVC   1(10,R2),0(R2)         last
         MVC   11(1,R2),CONCAT           table
         XC    12(2,R2),12(R2)              entry.
         L     R2,ALLEN            Get total length
         LA    R2,16(,R2)             of storage required.
         LR    R0,R2               Use R0 for GETMAIN
       GETMAIN R,LV=(0)
         ST    R1,8(0,R3)          Put address into DDtable entry.
         ST    R2,0(,R1)           Length of GETMAIN now in table.
         STH   R8,4(,R1)           Set number of directory entries,
         MVC   6(2,R1),HCONCAT        and number of concatentaions.
         LA    R8,8(0,R1)          Establish table base.
         SR    R6,R6               Clear work register.
         MVC   SAVEAREA+12(TBLNTRYS*4),ATBL0
         LA    R2,ATBL0-4          Set index pointer.
         LA    R15,*+4             Top of loop address
         SPACE 1
         LA    R2,4(,R2)           Point to next storage index.
         C     R2,AATBL            Beyond allocated indexes?
         BH    TBLOUT2                -yes-
         TM    0(R2),X'80'         GETMAIN'd area
         BZR   R15                    -no -   Loop back.
         L     R14,0(,R2)          Adjust the address
         LA    R14,8(,R14)            for the prefix area
         ST    R14,0(,R2)                and put it back.
         BR    R15                 Loop
TBLOUT2  DS    0H
         LA    R2,ATBL0            Get address of 1st storage index.
         LR    R5,R2               Say this points to the least.
         L     R3,ATBL0            Get address of 1st storage sector.
TBLOUT3  DS    0H
         LA    R2,4(0,R2)          Point to next storage index.
         C     R2,AATBL            Out of indexes?
         BH    TBLOUT4                -yes- Ready to move.
         L     R4,0(0,R2)          Get address of comparator.
         CLC   0(8,R4),0(R3)       This table entry less than current?
         BNL   TBLOUT3                -no - keep looking
         LR    R3,R4                  -yes- save sector address and
         LR    R5,R2                        index address.
         B     TBLOUT3             Keep looking.
TBLOUT4  DS    0H
         CLC   =XL8'FFFFFFFFFFFFFFFF',0(R3) Lowest at high-values?
         BE    TBLOUT5                         -yes- table is complete.
         IC    R6,13(R3)           Get number of
         N     R6,=F'31'              'user' halfwords
         SLL   R6,1                      into a length.
         LA    R6,13(0,R6)         Incement by fixed length minus 1
         EX    R6,MVC_DRCTRY          to pick-up the directry entry.
         LA    R6,1(0,R6)          Get true entry length.
         AR    R3,R6               Point to next temp entry and
         ST    R3,0(0,R5)             reset the sector address.
         AR    R8,R6               Point to next final slot.
         B     TBLOUT2             Start again.
MVC_DRCTRY     MVC   0(0,R8),0(R3) Move in the entry.
TBLOUT5  DS    0H
         MVC   ATBL0(TBLNTRYS*4),SAVEAREA+12
         LA    R3,ATBL0            Will need more indexes.
TBLOUT6  DS    0H
         TM    0(R3),X'80'         GETMAIN'd area.
         BZ    TBLOUT7                -no -
         NI    0(R3),X'7F'         Turn off the bit.
         L     R2,0(,R3)           Get storage address.
         L     R0,0(,R2)           Get storage length.
      FREEMAIN R,LV=(0),A=(R2)
TBLOUT7  DS    0H
         LA    R3,4(0,R3)          Point to next index.
         C     R3,AATBL            All done?
         BHR   R9                     -yes-  Exit via BAL register.
         B     TBLOUT6                -no -  Go free it.
         TITLE                     '<< Load/search a pds directory     >
                                        Warnings, errors and abends >>'
ABEND    DS    0H
         ABEND 383,DUMP,STEP
         SPACE 3
BADPARMS DS    0H
         WTO   'STSS383  :  Incorrect number of parameters. Run abortedx
               ',ROUTCDE=(11),DESC=(6)
         B     ABEND
         SPACE 3
BADIO    DS    0H
         WTO   'STSS383  :  Raised unrecognized sense bits from I/O',  x
               ROUTCDE=(11),DESC=(6)
         B     ABEND
         SPACE 3
BADTBL   DS    0H
         WTO   'STSS383  :  Excessive table allocations. run aborted', x
               ROUTCDE=(11),DESC=(6)
         B     ABEND
         SPACE 3
XTBL     DS    0H
         WTO   'STSS383  :  Excessive ddname requests. run aborted',   x
               ROUTCDE=(11),DESC=(6)
         B     ABEND
         TITLE                     '<< Load/search a pds directory     >
                                Release previously acquired storage >>'
FREEALL  DS    0H
         LA    R6,DDTBL-DDNTRY     Pre-set for indexes.
         LA    R6,DDNTRY(,R6)      Point to next index.
         CLC   BLANK8,0(R6)        Active index?
         BE    RTNXT                  -no -  All done.
         BAL   R9,FREEANY          Free this index and
         MVC   0(8,R6),BLANK8         de-activate it.
         B     FREEALL+4           Loop for next index.
         SPACE 3
FREEONE  DS    0H
         L     R3,0(,R1)           Address the 1st parameter.
         LA    R6,DDTBL-DDNTRY     Pre-set for indexes.
         LA    R6,DDNTRY(,R6)      Point to next index.
         CLC   BLANK8,0(R6)        Active index?
         BE    RTNXT                  -no -  All done.
         CLC   0(8,R6),0(R3)       Is the DDNAME matched?
         BE    *+14                   -yes-
         CLC   8(4,R6),0(R3)       How about table address?
         BNE   FREEONE+8              -no -  Go bump to next index.
         BAL   R9,FREEANY          Free this index.
         LA    R7,DDLAST-1         Calculate residual
         SR    R7,R6                  length of index entries
         EX    R7,MINUS_DDNTRY           to eliminate this entry.
         B     RTNXT               All done.
         SPACE 1
MINUS_DDNTRY   MVC   0(0,R6),DDNTRY(R6)  Overlay/lop off this entry.
         SPACE 3
FREEANY  DS    0H
         L     R2,8(0,R6)          Get the directory table address.
         L     R0,0(,R2)           Get the directory table length.
         LTR   R0,R0               Table formatted for COBOL?
         BNZ   *+12                   -no -
         LH    R0,4(,R2)              -yes-   Calculate
         MH    R0,=H'22'                         its length.
      FREEMAIN R,LV=(0),A=(R2)
         BR    R9                  Exit via BAL register.
         TITLE                     '<< Load/search a pds directory     >
                                                   Search routines >>'
SRCHCLC  CLC   0(0,R3),0(R4)
SRCHMAX  DS    F
         SPACE 2
SEARCH   DS    0H
         L     R1,APARMS           Get parameter list address.
         L     R3,4(,R1)           Address the 2nd and
         L     R8,8(,R1)              3rd parameters.
         LA    R1,8(,R3)           Pre-set end-of-search-name address
         TRT   0(8,R3),TOBLNK      Find a blank.
         BCTR  R1,0                Calculate machine instruction
         SR    R1,R3                  length of the search name.
         L     R5,ADDNTRY          Get the index.
         L     R4,8(,R5)           Get the directory table address.
         LH    R7,4(,R4)           Get the number of directory entries.
         SR    R6,R6               Thereby calculate
         M     R6,=F'22'              the address
         LA    R6,8(R4,R7)               beyond the last entry and
         ST    R6,SRCHMAX                   save the address.
         L     R2,0(,R4)           Get the directory table length.
         LTR   R2,R2               COBOL formatted table.
         BZ    SEARCH40               -yes-
         LA    R6,8(R4,R2)         Address beyond the last table entry
         ST    R6,SRCHMAX             and save it.
SEARCH10 DS    0H
         LH    R2,4(,R4)           Get the member count.
         LA    R4,8(,R4)           Point to the first table entry.
SEARCH11 DS    0H
         EX    R1,SRCHCLC          Matched?
         BE    SEARCH60               -yes-
         BL    SEARCH70               -never-
         IC    R6,13(,R4)          Point
         N     R6,=F'31'              to
         SLL   R6,1                     next
         LA    R4,14(R6,R4)                entry.
         BCT   R2,SEARCH11         Decrement the count and loop back.
         B     SEARCH70            No match.
         EJECT
SEARCH40 DS    0H
         LA    R2,3                Set 2's exponent
         LA    R7,15                  and maximum entries.
         CH    R7,4(,R4)           Are there less than 15 entries.
         BNL   SEARCH10               -yes-  Use a serial search.
         LA    R14,*+4              Set top-of-loop address.
         LA    R2,1(,R2)           Increment 2's exponent.
         SLL   R7,1                Double
         LA    R7,1(,R7)              the maximum entries.
         CH    R7,4(,R4)           High enough yet?
         BLR   R14                    -no -  Keep bumping.
         LA    R7,1(,R7)           Double the maximum to a power of 2
         SRL   R7,1                   for the initial incr/decr count.
         SR    R6,R6               Calculate incr/decr width
         M     R6,=F'22'              from the count.
         LR    R6,R7               Save the value
         S     R6,=F'22'              minus 1 entry width.
         LA    R4,8(R4,R6)         Point to approximately mid-table.
SEARCH42 DS    0H
         SRL   R7,1                Cut the incr/decr value in half.
         C     R4,SRCHMAX          Beyond the table?
         BNL   *+16                   -yes-
         EX    R1,SRCHCLC          Are we matched?
         BE    SEARCH60               -yes-  Still need to dig further.
         BH    *+14                   -no, but need to look higher
         SR    R4,R7                  -no, but need to look lower.
         BCT   R2,SEARCH42         Decrement the count and try again.
         B     SEARCH45            Need to take one last peek.
         SPACE 1
         AR    R4,R7               Move the address higher.
         BCT   R2,SEARCH42         Decrement the count and try again.
SEARCH45 DS    0H
         C     R4,SRCHMAX          Beyond the table?
         BNL   SEARCH70               -yes-
         EX    R1,SRCHCLC          One last attempt to match
         BNE   SEARCH70               wasn't satisfied either.
         EJECT
SEARCH60 DS    0H
         ST    R4,0(,R8)           We may have the right entry already.
         LR    R7,R4               Keep the entry address.
         IC    R6,13(,R4)          Point
         N     R6,=F'31'              to
         SLL   R6,1                      next
         LA    R4,14(R6,R4)                 entry.
         C     R4,SRCHMAX          Too far?
         BNL   SEARCH80               -yes-
         EX    R1,SRCHCLC          Still matched?
         BNE   SEARCH80               -no -  I'm satisfied.
         CLC   0(8,R4),0(R7)       Concatenation of equal member names?
         BE    SEARCH60+6             -yes-  Don't want the concat.
         B     SEARCH60               -no -  Re-set and keep trying.
SEARCH70 DS    0H
         XC    0(4,R8),0(R8)       Indicate a "no-match"
         BR    R9                  Exit via BAL register.
         SPACE 3
SEARCH80 DS    0H
         TM    COBOLSW,X'40'       COBOL caller?
         BZR   R9                     -no -  Exit via BAL register.
         L     R3,8(,R5)           Address of
         LA    R3,8(,R3)              beginning of the table.
         SR    R7,R3               Displacement to the match.
         SR    R6,R6               Width
         D     R6,=F'22'              divided by 22 = count
         LA    R7,1(,R7)                 relative to 1.
         ST    R7,0(,R8)           Give COBOL caller subscript value.
         BR    R9                  Exit via BAL register.
         SPACE 1
         DS    0F
         SPACE 1
         TITLE                     '<< Load/search a pds directory     >
                                                      Storage areas >>'
RC       DC    F'0'                Return code.
         SPACE 1
ATBLNTRY DS    F
ALLEN    DC    F'0'
TBLEN    DC    A(4096*16-14-8)
         DC    A(DRCTBLK+2)
         SPACE 1
APARMS   DS    F
         SPACE 1
SAVEAREA DS    (3+TBLNTRYS)F
         SPACE 1
TOBLNK   DC    256X'00'
         ORG   TOBLNK+C' '
         DC    X'01'
         ORG
         SPACE 1
HCONCAT  DS    0H
         DC    X'0'
CONCAT   DC    XL1'0'
         EJECT
ADDNTRY  DS    F
         SPACE 2
DDTBL    DS    0F
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
         DC    CL8'        ',A(0)
DDLAST   DC    CL8'        ',A(0)
DDNTRY   EQU   *-DDLAST
BLANK8   DC    CL8'        '      These two definitions must
A0       DC    A(0)                  follow DDLAST.
         SPACE 2
COBOLSW  DS    XL1
         SPACE 3
         EJECT
         LTORG
         TITLE                     '<< Load/search a pds directory     >
                                                I/O control blocks >>'
         DS    0D
DRCTDCB  DCB   DSORG=PS,                                               x
               EODAD=EODRCT,                                           x
               MACRF=GL,                                               x
               BLKSIZE=256,RECFM=F,LRECL=256,                          x
               DDNAME=SYSUT1
         DS    0D
DCB_LEN  EQU   *-DRCTDCB
A_DCB    DCB   DSORG=PS,                                               x
               EODAD=EODRCT,                                           x
               MACRF=GL,                                               x
               BLKSIZE=256,RECFM=F,LRECL=256,                          x
               DDNAME=SYSUT1
         DS    0D
DRCTKEY  DS    CL8
DRCTBLK  DS    CL256
         SPACE 1
         TITLE                     '<< Load/search a pds directory     >
                                                 DSECTs and EQUates >>'
GETMAIN_VALUE  EQU   4096*16
AVAIL_VALUE    EQU   GETMAIN_VALUE-8-14
         YREGS
         PRINT NOGEN
         DCBD  DSORG=(QS),DEVD=(DA)
         END   STSS383
