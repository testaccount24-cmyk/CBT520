./ ADD NAME=$$INDEX$ 0100-02224-02224-1603-00008-00008-00000-PST0705
The following are the member names associated with the built-in function
named SCCALLOC for REXX.

$README  - How to install SCCALLOC
ID$S     - ID Assembler macro used within assembley of SCCALLOC
SCCALL$H - A 'help' file explaining the various SCCALLOC agruments,
           features, and funtionality
SCCALL$S - The Assembler source
./ ADD NAME=$README  0100-02224-02224-1601-00013-00013-00000-PST0705
SCCALLOC must be made an entry in one of the 3 Rexx function packages
 -- or --  a single load module availble via STEPLIB etc. The function
package is a more efficient operating environment but requires
re-assembley of the package for installation. Refer to the TSO REXX
reference manual for building REXX function pacakges.

To assemble the source as provided, the ID macro must be made available
to the Assembler. Copy and rename ID$S member from this package into
a library within the SYSLIB concatenation for the Assembler. The new
name will be  ID.

Link edit the assembled source as per the function package  -- or --
into a load library which will be available via STEPLIB etc.
./ ADD NAME=ID$S     0100-02224-02224-1537-00049-00049-00000-PST0705
         MACRO
&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY
         LCLC  &U,&LBL
.*
.*        macro used to:
.*    - generate the CSECT statement.
.*    - generate the USING, AMODE and RMODE statements for the CSECT.
.*    - generate an eye-catcher and date/time stamp (28 bytes total).
.*      (The values for date and time are the time of the Assembly.)
.*
.* The default for the USING statement is (register) 15.
.* Other defaults are as per the prototype above.
.*
.* If the CSECT requires multiple base registers, their specification
.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)
.*
.* This macro can also be used to generate only the eye-catcher and
.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO
.*
.* -----------------------Modification History-------------------------
.* 98-02-19 change from &SYSDATE to &SYSDATC
.*
&U       SETC  '15'
&LBL     SETC  ' '
         AIF   (K'&LABEL EQ 0).LBLSET
&LBL     SETC  '&LABEL'
.LBLSET  ANOP
         AIF   (T'&USING EQ 'O').USET
         AIF   ('&USING'(1,1) NE '(').ONEUSE
&U       SETC  '&USING'(2,K'&USING-2)
         AGO   .USET
.ONEUSE  ANOP
&U       SETC  '&USING'
.USET    ANOP
         AIF   ('&CSECT' EQ 'YES').CSECT
&LBL     DS    0H
         B     *+32
         AGO   .STAMP
.CSECT   ANOP
&LBL     CSECT
&LBL     AMODE &AMODE
&LBL     RMODE &RMODE
         USING &LABEL,&U
         BC    15,32(,15)
.STAMP   ANOP
         DS    CL4
         DC    CL8'&LBL'
         DC    CL16'&SYSDATC &SYSTIME'
         MEND
./ ADD NAME=SCCALL$H 0100-02224-02224-1534-00139-00139-00000-PST0705
 Name:        SCCALLOC

 Purpose:     Provide native REXX with the equivalent of TSO
              ALLOCATE and FREE

 Environment: REXX subroutine/function for Address TSO or MVS

 Features:    Refer to argument 1 formats


 Arguments:
           1. The first argument is the ddname operand. It may be
              specified in one of six  formats.
            .1  A single ddname representing the dd to be
                allocated/freed.
            .2  A list of ddnames to be freed. The ddnames must be
                separated by at least one blank. With this format,
                argument two is ignored.
            .3  A single ddname with a plus sign (+) appended as a
                suffix. This is to indicate that the dataset(s)
                specified at argument 2 are to be concatenated ahead
                of those aleady allocated to the specified ddname.
                Note that the ddname does not necessarily have to
                be pre-allocated for this format.
            .4  A single ddname with a question mark (?) appended as a
                suffix. This is to indicate that the dataset(s)
                specified at argument 2 are to be allocated only if
                the ddname is not already allocated. Note that the
                dataset(s) specified at argument 2 are verified
                even if the ddname is already allocated.
            .5  A single ddname with a equal sign (=) appended as a
                suffix. This is to indicate that the ddname
                specified at argument 2 is to be allocated to the
                datasets already allocated to the ddname (without
                the suffix) at argument 1.
            .6  A single ddname with an underscore (_) appended as a
                suffix. This is special means of telling SCCALLOC
                not to check the catalog and existence of the dataset(s)
                specified at argument 2. This format should be reserved
                for temporary (i.e. VIO) datasets.
            .7  A single ddname with left parenthesis appended as a
                suffix. This format will cause SCCALLOC to allocate a
                system determined ddname to a member (specified in
                argument 2) within the (first) dataset represented by the
                ddname specified (without the suffix) at argument 1.
                SCCALLOC will return the system determined ddname.
           2. (optional - if omitted the specified ddname is freed)
              The (list of) dataset name(s) to be allocated. Names
              must be specified in JCL format; quotes are not used,
              high level node is required.

              If allocating to the member level, specify the member
              name as per JCL; i.e. enclosed in parenthesis and
              appended to the library name.

              If allocating to a relative GDG, specify the GDG
              level as per JCL; i.e. enclosed in parenthesis and
              appended to the GDG index name.

              For formats 2, 5 and 7 of argument 1, argument 2
              also  has special format

            .2  null

            .5  The ddname from which the new allocation will be
                made.

            .7  The member name to which allocation is required.

 Results:     The direct result of the subroutine/function is a
              logical value indicating whether or not the requested
              function was performed. Refer to the example 1 below.

              The variable RC is set as per the return code from
              LOCATE/OBTAIN/DYNALLOC.

              For format 7 of argument 1, the result is the system
              determined ddname. If the dynamic allocation fails the
              the result is 0 (zero).

              In error situations, appropriate messages are generated.
              The messages after a DYNALLOC failure are formatted to
              assist the programmer maintaining the SCCALLOC program
              and are to be used in conjunction with the IBM manual
              "Authorized Assembler Programming Langauge Programs"
              (GC28-1645) chapter 23.  Error code 0218 0000 will be
              generated if the dataset is catalogued to a tape (i.e
              "not mounted") device.


 Examples:
  1. Conditional allocates as well as multiple frees.
      /* REXX */
      Call Initailize
      Call Process
      Call Terminate
      exit
      Initialize:
           dd_s = ''
           if SCCALLOC('DD1?','MY.DATASET')   then dd_s = dd_s 'DD1'
           if SCCALLOC('DD2?','YOUR.DATASET') then dd_s = dd_s 'DD2'
        return 0
      Terminate::
           if dd_s \= '' then SCCALLOC(dd_s)
        return 0

  2. Remove a specified dataset from the SYSEXEC allocation.
      /* REXX */
      ? = dsn4dd('SYSEXEC')
      if ? == arg(1) then dsn_s = ''
      else dsn_s = ?
      do i = 1 to rc-1
           ? = dsn4dd('SYSEXEC+'i)
           if ? \== arg(1) then dsn_s = dsn_s ?
      end
      call SCCALLOC 'SYSEXEC', dsn_s
      exit

 Notes:
   SCCALLOC will allocate only to existing datasets. It always uses
   a disposition of SHR.

   A relative GDG is automatically resolved to its absolute dataset
   name. Do not use SCCALLOC to achieve that resolution; rather use
   SCC@DSN to determine an absolute gdg name without allocating it.

   SCCALLOC provides only limited allocations operands i.e. DSNAME
   DDNAME/FILE and SHR. SCCALLOC's purpose is to allow a non-TSO
   application to allocate to existing datasets.  TSO applications
   should utilize the ALLOCATE command unless a feature of SCCALLOC
   is required.

   If an uncataloged dataset is (pre)allocated and format 3 of
   argument 1 for that ddname is requested, a DYNALLOC failure will
   occur.

   Failures may render an unexpected allocation environment i.e
   partial unallocates/allocates

./ ADD NAME=SCCALL$S 0100-02224-02224-1513-00916-00916-00000-PST0705
ALLOC    TITLE            '<< REXX - Dynamic dataset allocation        X
                                                      Documentation >>'
* Refer to  QW R=SCCALLOC  for description of how to use SCCALLOC
*
* Written originally for the REXX exec UPDATE (May 1996)
*
* This program could be made re-entrant with little difficulty
* but since it is part of a IRXFLOC function package, the whole
* function package must be made re-entrant first.
*
* Support documentation for DYNALLOC is contained in the IBM manual
* "Authorized Assembler Programming" (GC28-1645) chapter 23.
*
         TITLE            '<< REXX - Dynamic dataset allocation        X
                                                     System Linkage >>'
SCCALLOC ID    R12
         SPACE 2
         PRINT NOGEN
         STM   R14,R12,12(R13)
         LR    R12,R15
         LA    R0,WORKLEN
      GETMAIN  R,LV=(0)
         USING GET_MAIN,R1
         ST    R13,SAVEAREA+4
         ST    R1,8(,R13)
         LR    R15,R13
         LR    R13,R1
         LM    R0,R1,20(R15)
         DROP  R1
         USING GET_MAIN,R13
         XC    RC,RC
         B     MAINLINE
         SPACE 3
RC       DS    0F
         DS    AL1
RC1      DS    AL1
RC2      DS    AL1
RC3      DS    AL1
         SPACE 3
RTNXT    DS    0H
         LR    R2,R13
         L     R13,SAVEAREA+4
         LA    R0,WORKLEN
      FREEMAIN R,LV=(R0),A=(R2)
         XC    8(4,R13),8(R13)
         XC    16(4,R13),16(R13)   R15 (return code) always
         LM    R14,R12,12(R13)        get set to zero.
         BR    R14
         USING EFPL,R1
         USING S99TUNIT,R7
         USING ENVBLOCK,R8
         USING EVALBLOCK,R11
         TITLE            '<< REXX - Dynamic dataset allocation        X
                               Adressability and Re-entrancy set-up >>'
MAINLINE DS    0H
         LR    R8,R0               Address the environment block.
         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.
         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK.
         L     R11,0(,R11)
         LA    R0,1
         ST    R0,EVALBLOCK_EVLEN
         MVI   EVALBLOCK_EVDATA,C'0'
         DROP  R1
         DROP  R8
         LA    R7,TU@___DDNAM
         XC    S99TUNIT(6),S99TUNIT
         MVI   S99TUKEY+1,DALDDNAM
         MVI   S99TUNUM+1,X'01'
         MVI   S99TUPAR,C' '       Pre-clear
         MVC   S99TUPAR+1(7),S99TUPAR the ddname
         ST    R7,FREE_TUPL
         ST    R7,CONC_TUPL
         ST    R7,DAL_TUPL+4
         MVI   DD_SW,NULL
         XC    CONCAT_COUNT,CONCAT_COUNT
         MVI   TRTABLE-1,X'FF'     Pre-set table value.
         XC    TRTDSN,TRTDSN
         MVI   TRTDSN+C' ',X'01'
         TITLE            '<< REXX - Dynamic dataset allocation        X
                                                 Process the DDname >>'
         BAL   R14,STRIP           Strip out arg(1).
         B     MISSING_DDNAME      Arg(1) not specified.
         LA    R0,8                Is arg(1)
         CR    R15,R0                 longer than 8 bytes?
         BH    MULTI_FREE                -yes-
         EX    R15,TRT_ARG         Does arg(1) contain a blank?
         BNZ   MULTI_FREE             -yes-
         LA    R2,1(,R15)          Get length of the value.
         CLI   0(R4),C'_'          Avoid LOCATE/OBTAIN?
         BNE   *+12                   -no -
         OI    DD_SW,@VIO          Set the indicator.
         B     CLIP_ARG1
         CLI   0(R4),C'='          Copy a DD?
         BNE   *+12                   -no -
         OI    DD_SW,COPY_DD       Set the indicator.
         B     CLIP_ARG1
         CLI   0(R4),C'+'          Forcing concatenation?
         BNE   *+12                   -no -
         OI    DD_SW,CONCAT_FORCE  I will have to concatenate.
         B     CLIP_ARG1
         SPACE 1
         CLI   0(R4),C'?'          Request conditional?
         BNE   *+12                   -no -
         OI    DD_SW,CONDITIONAL   I will have to concatenate.
         B     CLIP_ARG1
         SPACE 1
         CLI   0(R4),C'('          Request conditional?
         BNE   CLIP_ARG1+2            -no -
         OI    DD_SW,@MEMBER       I have to allocate to a member.
         B     CLIP_ARG1
CLIP_ARG1  DS  0H
         BCTR  R2,0                Exclude one byte from the length.
         SPACE 1
         STH   R2,S99TULNG
         BCTR  R2,0                Save
         EX    R2,MVC_TU              the ddname.
         TITLE            '<< REXX - Dynamic dataset allocation        X
                   Collect and verify the dataset names from arg(2) >>'
         BAL   R14,STRIP           Strip out arg(2).
         B     FREE_ONLY           No arg(2) means do a FREE.
         MVI   TRTDSN+C')',X'01'
         MVI   TRTDSN+C'(',X'02'
         XC    LOCATE_OBTAIN,LOCATE_OBTAIN
         MVI   LOCATE_PLIST,X'44'
         LA    R0,WORKAREA
         ST    R0,LOCATE@WORK
         ST    R0,OBTAIN@WORK
         MVI   OBTAIN_PLIST,X'C1'
         LA    R0,VOLSER
         ST    R0,OBTAIN@VOLSER
         LA    R7,DSN_LIST
         XC    S99TUNIT(4),S99TUNIT
         MVI   S99TUKEY+1,DALDSNAM Set the key
         MVI   S99TUNUM+1,X'01'
         SR    R2,R2
ARG2_DSN DS    0H
         MVI   S99TUPAR,C' '       Pre-clear
         MVC   S99TUPAR+1(44),S99TUPAR  for a dsn plus one byte
         LA    R0,S99TUPAR         A(DSN) for
         ST    R0,LOCATE@DSN          LOCATE and
         ST    R0,OBTAIN@DSN             OBTAIN plist's.
         LR    R15,R4              Calculate
         SR    R15,R3                 the residual length.
         LA    R5,43               Maximum dsn length
         CR    R15,R5              Residual < 43 ?
         BNL   *+6                    -no -
         LR    R5,R15                 -yes-  Use the shorter.
         LA    R1,1(R5,R3)         Pre-set R1 in case TRT misses.
         EX    R5,TRT_ARG          Find delimiter within dsn.
         BZ    NOT_GDG
         CLI   1(R1),C'0'          Is this a relative GDG?
         BE    USE_GDG                -yes-
         CLI   1(R1),C'-'          Is this a relative GDG?
         BNE   NOT_GDG                -no -
USE_GDG  DS    0H
         LR    R14,R1
         LA    R5,8                Maximum length.
         CR    R15,R5              More than residual length?
         BNL   *+6                    -no -
         LR    R5,R15                 -yes-  Use residual length.
         LA    R1,1(R5,R3)         Pre-set R1 in case there is no hit.
         EX    R5,TRT_GDG          Find the delimiting paren.
         AR    R1,R2               Right paren adjustment.
NOT_GDG  DS    0H
         LR    R14,R1              Hang on to the delimit address.
         SR    R1,R3               Calculate length of dsn and
         STH   R1,S99TULNG            save it in case we don't LOCATE.
         BCTR  R1,0                Instruction length.
         EX    R1,MVC_TU           Pick-up the dsn.
         SPACE 1
         LA    R3,1(,R14)          Set the 'scanned-to' address.
         ST    R2,DBLWD            Preserve R2 across LOCATE/OBTAIN
         TM    DD_SW,@VIO          Allocating to existing VIO?
         BO    NO_OBTAIN              -yes-
         TM    DD_SW,@MEMBER       Allocating a member?
         BZ    *+12                   -no -
         MVI   S99TUKEY+1,DALMEMBR    -yes-  Set the key and
         B     NO_OBTAIN                        don't LOCATE/OBTAIN.
         TM    DD_SW,COPY_DD       Copying a DDname allocation?
         BZ    *+16                   -no -
         MVI   S99TULNG+1,X'08'       -yes-  Force a length of 8,
         MVI   S99TUKEY+1,DALDDNAM              set the key and
         B     NO_OBTAIN                           don't LOCATE/OBTAIN.
         SPACE 1
       LOCATE  LOCATE_PLIST
         LTR   R15,R15             Cataloged?
         BNZ   LOCATE_ERROR           -no -
         TRT   S99TUPAR(45),TRTDSN LOCATE will have resolved GDG.
         LA    R0,S99TUPAR
         SR    R1,R0               Calculate DSN length
         STH   R1,S99TULNG            and save it.
         TM    DEV_CODE+2,X'20'    Is the device class 'dasd'?
         BZ    NO_OBTAIN              -no -
         MVC   VOLSER,WA_VOLSER    Use the volser as per catalog.
       OBTAIN  OBTAIN_PLIST
         LTR   R15,R15             Is there a VTOC entry on the volume?
         BNZ   OBTAIN_ERROR           -no -
NO_OBTAIN  DS  0H
         L     R2,DBLWD            Recover R2
         LH    R1,S99TULNG         Need the DSN length again.
         LA    R7,7(R1,R7)         Calculate address of next text unit
         SRL   R7,1                   rounded to
         SLL   R7,1                      halfword.
         XC    S99TUNIT(4),S99TUNIT
         MVI   S99TUKEY+1,DALDSNAM Pre-set the key.
         MVI   S99TUNUM+1,X'01'
         CR    R3,R4               At the end of arg(2)?
         BNL   DD_SEARCH              -yes-
         BCT   R2,*+8              Member name to follow?
         B     NEXT_ARG2              -no -
         CR    R3,R4               Reached the end of the arg?
         BNL   DD_SEARCH              -yes-
         LR    R15,R4              Calculate
         SR    R15,R3                 the residual length.
         LA    R5,8                Max. member name length
         CR    R15,R5              More than residual length?
         BNL   *+6                    -no -
         LR    R5,R15                 -yes-  Use residual length.
         LA    R1,1(,R5)           Pre-set R1 in case there is no hit.
         EX    R5,TRT_ARG          Find the end of the member name.
         CLI   0(R1),C')'
         BNE   DSN_ERROR
         LR    R14,R1              Hang on to the delimit address.
         SR    R1,R3               Calculate membername length
         STH   R1,S99TULNG           and save it.
         SR    R15,R1              Decrement arg(2) residual length.
         BCTR  R1,0                Instruction length.
         EX    R1,MVC_TU           Pick-up the member name
         MVI   S99TUKEY+1,DALMEMBR (Re)set the key.
         LH    R1,S99TULNG         Need the mem name length again.
         LA    R7,7(R1,R7)         Calculate address of next text unit
         SRL   R7,1                   rounded to
         SLL   R7,1                      halfword.
         XC    S99TUNIT(4),S99TUNIT
         MVI   S99TUKEY+1,DALDSNAM Pre-set the key.
         MVI   S99TUNUM+1,X'01'
         LA    R3,2(,R14)          Set the 'scanned-to' address
NEXT_ARG2  DS  0H
         CR    R3,R4               At the end of arg(2)?
         BNL   DD_SEARCH              -yes-
         LH    R1,CONCAT_COUNT
         LA    R1,1(,R1)
         STH   R1,CONCAT_COUNT
         TRT   0(256,R3),TRTABLE
         LR    R3,R1
         LR    R15,R4
         SR    R15,R3
         B     ARG2_DSN
         USING PSA,R0
         USING TCB,R1
         USING INFMJFCB,R5
         TITLE            '<< REXX - Dynamic dataset allocation        X
                       Determine if/how ddname is already allocated >>'
FREE_ONLY  DS  0H
         OI    DD_SW,FREE_FORCE
DD_SEARCH  DS  0H
         SR    R0,R0               Used later
         LR    R5,R0                  for IC/ICM instructions.
         L     R1,PSATOLD          Get TCB address.
         L     R15,TCBTIO           Get TIOT address.
         DROP  R1
         USING TIOT1,R15
FIND_DD  DS    0H
         CLC   TIOEDDNM,DDNAME     Is this the requester's DDname?
         BE    FOUND_DD               -yes-
         CLI   TIOELNGH,X'00'      End of TIOT's?
         BE    SEARCHED               -yes-
         IC    R0,TIOELNGH         Get TIOT length and
         AR    R15,R0                 point to next TIOT.
         B     FIND_DD             Loop back.
FOUND_DD DS    0H
         OI    DD_SW,ALLOCATED     Say 'DD is allocated'
         TM    DD_SW,FREE_FORCE    Asking for FREE?
         BO    ONE_FREE               -yes-   This is easy.
         TM    DD_SW,CONDITIONAL   Conditional allocate?
         BO    RC@0                   -yes-   This is easier.
         TM    DD_SW,@MEMBER       Requested to allocate to a member?
         BO    COLLECT                -yes-   I have to get dsn.
         TM    DD_SW,COPY_DD       Requested to copy an allocation?
         BO    COLLECT                -yes-   I have to get dsn.
         TM    DD_SW,CONCAT_FORCE  Asking for concatenation?
         BZ    SEARCHED               -no -   I presume REUSE
COLLECT  DS    0H
         ICM   R5,7,TIOEJFCB       Get the JFCB TTR address.
         LTR   R5,R5               Is there a JFCB address?
         BZ    COLLECTED              -no -
         LA    R5,16(,R5)
         LH    R1,CONCAT_COUNT     Count
         LA    R1,1(,R1)              another
         STH   R1,CONCAT_COUNT           concatenated dataset.
         MVC   S99TUPAR(44),JFCBDSNM   Get the DSN
         LA    R1,S99TUPAR+44      In case of full name.
         TRT   S99TUPAR(44),TRTDSN Find the blank.
         LA    R0,S99TUPAR         Calculate
         SR    R1,R0                  length of DSN
         STH   R1,S99TULNG               and save it.
         LA    R7,7(R1,R7)         Calculate address of next text unit
         SRL   R7,1                   rounded to
         SLL   R7,1                      halfword.
         XC    S99TUNIT(4),S99TUNIT  Pre-clear the next text unit.
         MVI   S99TUKEY+1,DALDSNAM Pre-set the key.
         MVI   S99TUNUM+1,X'01'
         TM    JFCBTSDM,JFCPAT     DSCB patterning done?
         BO    COLLECTED             -yes-
         CLI   JFCBELNM,C' '       Is there a member name?
         BE    COLLECTED             -no -
         MVI   S99TUKEY+1,DALMEMBR (Re)set the key.
         MVC   S99TUPAR(8),JFCBELNM   Get the GDG/member name
         LA    R1,S99TUPAR+8       In case of full member name.
         TRT   S99TUPAR(8),TRTDSN  Find the blank.
         LA    R0,S99TUPAR         Calculate
         SR    R1,R0                  length of member name
         STH   R1,S99TULNG               and save it.
         LA    R7,7(R1,R7)         Calculate address of next text unit
         SRL   R7,1                   rounded to
         SLL   R7,1                      halfword.
         XC    S99TUNIT(4),S99TUNIT  Pre-clear the next text unit.
         MVI   S99TUKEY+1,DALDSNAM Pre-set the key.
         MVI   S99TUNUM+1,X'01'
COLLECTED  DS  0H
         SR    R0,R0
         IC    R0,TIOELNGH         Get TIOT length.
         LTR   R0,R0               Is there any length?
         BZ    SEARCHED               -no -   Done collecting
         AR    R15,R0              Point to next TIOT.
         CLC   TIOEDDNM,=CL8'        '   Still same DDname?
         BE    COLLECT                      -yes-   collect the DSN
         SPACE 3
         DROP  R15
         DROP  R0
         USING S99RB,R2
         USING S99TUPL,R6
         TITLE            '<< REXX - Dynamic dataset allocation        X
                                    Proceed with required allocates >>'
SEARCHED DS    0H
*
* Note that the logic at FOUND_DD honours a valid FREE request.
* Here we handle the superfluous FREE request.
*
         TM    DD_SW,FREE_FORCE    FREE an un_allocated ddname?
         BO    RC@0                   -yes-  Ignore the request.
         TM    DD_SW,@MEMBER
         BO    ALLOC_MEM
         TM    DD_SW,COPY_DD
         BO    COPY@DD
         TM    DD_SW,ALLOCATED
         BZ    FREED
         LA    R2,S99_RB           Address the request block
         MVI   S99VERB,S99VRBUN       and set its 'verb'.
         LA    R6,FREE_TUPL        Address the text unit parameter list
         ST    R6,S99TXTPP            and put it int the request block.
         LA    R7,TU@___DDNAM      Address the text unit
         MVI   S99TUKEY+1,DUNDDNAM    to use 'unallocate' as the key.
         SPACE 1
         LA    R1,S99_PLIST        Get the plist address.
      DYNALLOC
         LTR   R15,R15
         BNZ   DYN_ERROR
         B     FREED
COPY@DD  DS    0H
         LH    R2,CONCAT_COUNT
         BCTR  R2,0
         STH   R2,CONCAT_COUNT
         LA    R7,DSN_LIST         Address the DALDDNAM and
         LA    R6,TU@DALSTATS         DALSTATS text units to
         STM   R6,R7,BUILD_TUPL          start the TUPL list.
         MVC   TU@___DDNAM+S99TULNG-S99TUNIT(10),S99TULNG
         LH    R14,S99TULNG        Calculate
         LA    R7,7(R14,R7)           address of DALDSNAM text unit
         SRL   R7,1                       rounded up
         SLL   R7,1                          to a halfword.
         B     JUMP_IN             Jump into the middle of the logic.
FREED    DS    0H
*
* Allocate the first dataset within the concatenation.
* We use the real DDNAME for this;
*
         MVI   S99TUKEY+1-S99TUNIT+TU@___DDNAM,DALDDNAM
         MVC   BUILD_TUPL(2*4),DAL_TUPL  Get the 1st 2 TU addresses.
         LA    R7,DSN_LIST         Top of the list.
JUMP_IN  DS    0H
         LA    R2,S99_RB           Address the request block
         MVI   S99VERB,S99VRBAL       and set its 'verb'.
         LA    R6,BUILD_TUPL       Address the text unit parameter list
         ST    R6,S99TXTPP            and put it in the request block.
         LA    R6,2*4(,R6)         Point to next available TUPL cell
         ST    R7,S99TUPTR            and put A(DSN TU) there.
         LR    R15,R7              Convenient for compare @ next TU.
         LH    R14,S99TULNG        Calculate
         LA    R7,7(R14,R7)           address of next TU
         SRL   R7,1                       rounded up
         SLL   R7,1                          to a halfword.
         CLC   S99TUKEY,0(R15)     Next TU also for a DSN?
         BE    NO_MEM1                -yes-   TU doesn't belong here.
         LA    R6,4(,R6)           Point to next available TUPL cell
         ST    R7,S99TUPTR            and put A(mem TU) there.
         LH    R14,S99TULNG        Calculate
         LA    R7,7(R14,R7)           address of next TU
         SRL   R7,1                       rounded up
         SLL   R7,1                          to a halfword.
NO_MEM1  DS    0H
         OI    S99TUPTR,S99TUPLN   Indicate end of TUPL.
         LA    R1,S99_PLIST        Get the plist address.
      DYNALLOC
         LTR   R15,R15
         BNZ   DYN_ERROR
         LH    R10,CONCAT_COUNT
         LTR   R10,R10
         BZ    DONE_IT
*
* Allocate the datasets which require concatenation.
* Ask the system to assign and return an available ddname.
*
         LA    R0,TU@DALRTDDN
         ST    R0,BUILD_TUPL+1*4
         LA    R9,DD_LIST
ALLOC_LOOP DS  0H
         LA    R6,BUILD_TUPL+2*4   Point to available TUPL cell
         ST    R7,S99TUPTR            and put A(DSN TU) there.
         LR    R15,R7              Convenient for compare @ next TU.
         LH    R14,S99TULNG        Calculate
         LA    R7,7(R14,R7)           address of next TU
         SRL   R7,1                       rounded up
         SLL   R7,1                          to a halfword.
         CLC   S99TUKEY,0(R15)     Next TU also for a DSN?
         BE    NO_MEM2                -yes-   TU doesn't belong here.
         LA    R6,4(,R6)           Point to next available TUPL cell
         ST    R7,S99TUPTR            and put A(mem TU) there.
         LH    R14,S99TULNG        Calculate
         LA    R7,7(R14,R7)           address of next TU
         SRL   R7,1                       rounded up
         SLL   R7,1                          to a halfword.
NO_MEM2  DS    0H
         OI    S99TUPTR,S99TUPLN   Indicate end of TUPL.
         LA    R1,S99_PLIST        Get the plist address.
      DYNALLOC
         LTR   R15,R15
         BNZ   DYN_ERROR
         MVI   TU@DALRTDDN+5,X'08' Force the length of DDname
         MVC   0(10,R9),TU@DALRTDDN+4  Pick-up the assignment.
         LA    R9,10(,R9)          Next one goes here.
         BCT   R10,ALLOC_LOOP      Count and loop.
         SPACE 2
         MVI   S99VERB,S99VRBCC    Set for concatenation.
         LA    R7,DD_LIST-14       Use a
         MVC   S99TUNIT(14),TU@___DDNAM  copy of the general DDNAM TU
         MVI   S99TULNG+L'S99TULNG-1,X'08'
         MVI   S99TUKEY+1,DCCDDNAM          with required key set.
         LH    R1,CONCAT_COUNT     Pick-up the concatenation count
         LA    R1,1(,R1)              make it relative to zero for
         STH   R1,S99TUNUM               the number of DD's.
         ST    R7,BUILD_TUPL       (Re)build
         LA    R7,TU@DCCPERMC         a two
         ST    R7,BUILD_TUPL+4           text unit
         OI    BUILD_TUPL+4,S99TUPLN        parm list.
         LA    R1,S99_PLIST        Get the plist address.
      DYNALLOC
         LTR   R15,R15
         BNZ   DYN_ERROR
DONE_IT  DS    0H
         MVI   EVALBLOCK_EVDATA,C'1'
RC@0     DS    0H
         SR    R15,R15
         CVD   R15,DBLWD
         B     R15_RC
ONE_FREE DS    0H
         LA    R2,S99_RB           Address the request block
         MVI   S99VERB,S99VRBUN       and set its 'verb'.
         LA    R6,FREE_TUPL        Address the text unit parameter list
         ST    R6,S99TXTPP            and put it int the request block.
         SPACE 1
         LA    R1,S99_PLIST        Get the plist address.
      DYNALLOC
         LTR   R15,R15
         BNZ   DYN_ERROR
         B     DONE_IT
         SPACE 3
MULTI_FREE  DS 0H
         LA    R0,8                Maximum length for TRT instruction.
         LR    R5,R4               Calculate
         SR    R5,R3                  residual length
         CR    R5,R0               Residual > maximum?
         BNH   *+6                    -no -
         LR    R5,R0                  -yes-  Use the maximum
         LA    R1,1(,R4)           Pre-set R1 in case there is no hit.
         EX    R5,TRT_ARG          Find the delimiting blank.
         LR    R0,R1               Hang on to the delimit address.
         SR    R1,R3               Calculate the length of ddname,
         STH   R1,S99TULNG            save it and
         BCTR  R1,0                      make it an instruction length
         EX    R1,MVC_TU                    to move the ddname.
         LR    R3,R0               Set the scanned-to address
         LA    R2,S99_RB           Address the request block
         MVI   S99VERB,S99VRBUN       and set its 'verb'.
         LA    R6,FREE_TUPL        Address the text unit parameter list
         ST    R6,S99TXTPP            and put it int the request block.
         SPACE 1
         LA    R1,S99_PLIST        Get the plist address.
      DYNALLOC
         LTR   R15,R15
         BNZ   *+8
         MVI   EVALBLOCK_EVDATA,C'1'
         CR    R3,R4               All scanned?
         BNL   RC@0                   -yes-
         TRT   0(256,R3),TRTABLE   Find a non-blank
         LR    R3,R1               Set the 'scanned-to' address.
         B     MULTI_FREE          Go process another ddname.
         TITLE            '<< REXX - Dynamic dataset allocation        X
                            Allocate to a member of an allocated DD >>'
ALLOC_MEM  DS  0H
         TM    DD_SW,ALLOCATED     Did we find the DD?
         BZ    NO_DD4MEM              -no -
         LA    R2,S99_RB           Address the DYNALLOC request block.
         MVI   S99VERB,S99VRBAL    Set the vert to allocate.
         LA    R6,BUILD_TUPL       Address the TUPL work area and
         ST    R6,S99TXTPP            put it into the request block.
         LA    R7,DSN_LIST         Address the
         ST    R7,S99TUPTR            first text unit.
         LH    R1,S99TULNG         Address
         LA    R7,7(R1,R7)            the
         SRL   R7,1                      second (i.e. DSN)
         SLL   R7,1                         text
         ST    R7,S99TUPTR+4                   unit.
         LH    R1,S99TULNG         Address
         LA    R7,7(R1,R7)            the
         SRL   R7,1                      third
         SLL   R7,1                         text
         ST    R7,S99TUPTR+8                   unit and
         MVC   0(14,R7),TU@DALRTDDN               put a text unit there
         LR    R0,R7               Preserve the address of the 3rd TU.
         LA    R7,14(,R7)          Address the
         ST    R7,S99TUPTR+12         fourth text unit area
         MVC   0(7,R7),TU@DALSTATS       and fill in that text unit.
         LR    R7,R0               3rd text unit required post DYNALLOC
         OI    S99TUPTR+12,S99TUPLN  Close the TUPL list.
         LA    R1,S99_PLIST        Get the plist address.
      DYNALLOC
         LTR   R15,R15
         BNZ   DYN_ERROR
         MVC   EVALBLOCK_EVDATA(8),S99TUPAR
         MVI   EVALBLOCK_EVLEN+3,X'08'
         B     RC@0
         SPACE 3
         DROP  R5
         USING IRXEXTE,R9
         USING ENVBLOCK,R8
         TITLE            '<< REXX - Dynamic dataset allocation        X
                Assign the value from the record to a REXX variable >>'
*
* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
         SPACE 1
PLIST_EXCOM DC A(EXCOM_LIT,0,0)
         DC    A(@SHV+X'80000000')
         SPACE 1
@SHV     DS    0A
         DC    2A(0)
         DC    C'S'
         DS    XL3'000000'
         DC    5A(0)
         SPACE 1
EXCOM_LIT DC   CL8'IRXEXCOM'
         SPACE 3
ASSIGN_VAR  DS  0H
         L     R15,IRXEXCOM        Get routine's address from vector.
         LA    R1,PLIST_EXCOM
         LA    R0,ENVBLOCK         Make sure REXX knows environment.
         BALR  R14,R15
         B     RTNXT
*
* Alternative to variable name assignment is to STACK the value.
*
* Refer to the IRXSTK   routine; pages 485-490 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
STK_FUNC DC    CL8'QUEUE   '
STK_PLIST  DC  A(STK_FUNC)
         DC    A(SHVVALA-SHVBLOCK+@SHV)
         DC    A(SHVVALL-SHVBLOCK+@SHV)
         DC    A(RC+X'80000000')
         ORG   ASSIGN_VAR      Overlay that code. It does not get used.
         TITLE            '<< REXX - Dynamic dataset allocation        X
                     Subroutine to Strip Leading && Trailing Blanks >>'
         USING ARGTABLE_ENTRY,R10
* Registers upon entry
*    R10 ==> argument table entry
*    R14 ==> exit address when agrument is null
*    R14+4=> normal exit
*
* Registers upon exit
*    R10 ==> next argument table entry.
*    R2    = 0 (zero)
*    R3  ==> leftmost non-blank byte of argument
*    R4  ==> rightmost non-blank byte of argument
*    R15   = R4 - R3 (length of argument minus 1)
         SPACE 2
TRT3     TRT   0(0,R3),TRTABLE
HEXFF    DC    X'FFFFFFFFFFFFFFFF'
         DS    XL1
TRTABLE  DS    XL256
         SPACE 2
STRIP    DS    0H
         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?
         BER   R14                              -no -
         L     R15,ARGTABLE_ARGSTRING_LENGTH
         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.
         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.
         SPACE 1
         LTR   R15,R15             Does the argument have any length?
         BZR   R14                    -NO - take abnormal exit.
         LA    R4,0(R15,R3)        Point just beyond ARG.
         MVC   TRTABLE,TRTABLE-1   Set to
         MVI   TRTABLE+C' ',X'00'     bypass blanks.
         BCTR  R15,0               Set length for TRT instruction.
         EX    R15,TRT3            Skip to non-blank.
         BZR   R14                 When all blank.
         LR    R3,R1               Re-set starting address.
STRIP@R  DS    0H
         BCTR  R4,0                Backpedal 1 byte.
         CLI   0(R4),X'40'         (still) at a blanK?
         BNE   STRIPPED               -no -
         CR    R4,R3                  -yes-  More to inspect?
         BH    STRIP@R                          -yes-
STRIPPED DS    0H
         LR    R15,R4              Calculate
         SR    R15,R3                 length of ARG - 1.
         SR    R2,R2               Pre-clear R2 for TRT
         BC    15,4(,R14)          Take normal exit.
         TITLE            '<< REXX - Dynamic dataset allocation        X
                                                Errors and messgaes >>'
*
* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
SAY_LIT        DC    CL8'WRITE   '
SAY_BUFF       DS    A
SAY_LEN        DS    F
SAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')
MISSING_DDNAME_MSG DC  C'First argument (DDNAME) missing.'
NO_DD4MEM_MSG  DC    C'Requested DDNAME is not allocated.'
DSN_ERROR_MSG      DC  C'Invalid dataset name construct.'
L_O_MSG  DC    C'       failed for '
L_O_LEN  EQU   *-L_O_MSG+44
DYN_MSG  DC    C'DYNALLOC error. R15='
DYN_R15  DS    CL8
         DC    C' Verb='
DYN_VERB DS    CL2
         DC    C' Flag1='
DYN_FLAG DS    CL4
         DC    C' Error code='
DYN_EC   DS    CL4
         DC    C'     '
DYN_MSG_L  EQU *-DYN_MSG
         SPACE 1
TU_MSG   DC    C'      Text unit Key='
TU_KEY   DS    CL4
         DC    C' count='
TU_COUNT DS    CL4
         DC    C' length='
TU_LENGTH DS   CL4
         DC    C' '
TU_MSG_L EQU   *-TU_MSG+1
         SPACE 1
TU_DATA  DS    CL44
         SPACE 3
DYN_ERROR  DS  0H
         CVD   R15,DBLWD
         ST    R15,RC
         UNPK  WORKAREA(9),RC(5)
         LA    R2,S99_RB
         UNPK  WORKAREA+8(15),S99RB+1(8)
         TR    WORKAREA(18),HEX_TR-C'0'
         MVC   DYN_R15,WORKAREA
         MVC   DYN_VERB,WORKAREA+8
         MVC   DYN_FLAG,WORKAREA+10
         MVC   DYN_EC,WORKAREA+14
         MVC   DYN_EC+5,WORKAREA+18
         L     R9,ENVBLOCK_IRXEXTE Make sure we have REXX vector table.
         LA    R0,DYN_MSG
         ST    R0,SAY_BUFF
         LA    R0,DYN_MSG_L
         ST    R0,SAY_LEN
         LA    R0,ENVBLOCK
         LA    R1,SAY_PLIST
         L     R15,IRXSAY
         BALR  R14,R15
         L     R6,S99TXTPP
TU_MSG_LOOP DS 0H
         L     R7,S99TUPTR
         UNPK  WORKAREA(13),S99TUNIT(7)
         TR    WORKAREA(12),HEX_TR-C'0'
         MVC   TU_KEY,WORKAREA
         MVC   TU_COUNT,WORKAREA+4
         MVC   TU_LENGTH,WORKAREA+8
         LH    R15,S99TULNG
         BCTR  R15,0
         EX    R15,MVC_TUPAR
         LA    R15,TU_MSG_L(,R15)
         LR    R0,R15
         LA    R15,TU_MSG
         TM    S99TUPL,S99TUPLN
         BO    R15_RC
         ST    R15,SAY_BUFF
         ST    R0,SAY_LEN
         LA    R0,ENVBLOCK
         LA    R1,SAY_PLIST
         L     R15,IRXSAY
         BALR  R14,R15
         LA    R6,4(,R6)
         B     TU_MSG_LOOP
LOCATE_ERROR   DS    0H
         MVC   L_O_MSG(6),=C'LOCATE'
         B     OBTAIN_ERROR+6
         SPACE 1
OBTAIN_ERROR   DS    0H
         MVC   L_O_MSG(6),=C'OBTAIN'
         SPACE 1
         CVD   R15,DBLWD
         L     R15,LOCATE@DSN
         LA    R0,L'L_O_MSG
         SR    R15,R0
         MVC   0(L'L_O_MSG,R15),L_O_MSG
         LA    R0,L_O_LEN
R15_RC   DS    0H
         ST    R15,SAY_BUFF
         ST    R0,SAY_LEN
         L     R9,ENVBLOCK_IRXEXTE Make sure we have REXX vector table.
         LA    R0,RC_LIT
         ST    R0,SHVNAMA-SHVBLOCK+@SHV
         LA    R0,2
         ST    R0,SHVNAML-SHVBLOCK+@SHV
         OI    DBLWD+7,X'0F'
         UNPK  WORKAREA(5),DBLWD+5(3)
         LA    R1,WORKAREA
         ST    R1,SHVVALA-SHVBLOCK+@SHV
         LA    R2,4
         LA    R3,*+4
         CLI   0(R1),C'0'
         BNE   *+10
         LA    R1,1(,R1)
         BCTR  R2,R3
         LA    R2,1(,R2)
         ST    R2,SHVVALL-SHVBLOCK+@SHV
         MVC   WORKAREA(5),0(R1)
         L     R15,IRXEXCOM        Get routine's address from vector.
         LA    R1,PLIST_EXCOM
         LA    R0,ENVBLOCK         Make sure REXX knows environment.
         BALR  R14,R15
         CLI   WORKAREA,C'0'
         BE    RTNXT
         B     CALL@SAY
         SPACE 2
NO_DD4MEM DS   0H
         LA    R15,NO_DD4MEM_MSG
         LA    R0,L'NO_DD4MEM_MSG
         B     SAY_CALL
         SPACE 2
DSN_ERROR DS         0H
         LA    R15,DSN_ERROR_MSG
         LA    R0,L'DSN_ERROR_MSG
         B     SAY_CALL
         SPACE 2
MISSING_DDNAME DS    0H
         LA    R15,MISSING_DDNAME_MSG
         LA    R0,L'MISSING_DDNAME_MSG
         B     SAY_CALL
SAY_CALL DS    0H
         ST    R15,SAY_BUFF
         ST    R0,SAY_LEN
         L     R9,ENVBLOCK_IRXEXTE Make sure we have REXX vector table.
CALL@SAY DS    0H
         LA    R0,ENVBLOCK
         LA    R1,SAY_PLIST
         L     R15,IRXSAY
         BALR  R14,R15
         LR    R2,R13
         L     R13,SAVEAREA+4
         LA    R0,WORKLEN
      FREEMAIN R,LV=(R0),A=(R2)
         XC    8(4,R13),8(R13)
         LM    R14,R12,12(R13)
         LA    R15,40
         BR    R14
         TITLE            '<< REXX - Dynamic dataset allocation        X
                                              Global Data Constants >>'
         SPACE 2
         DS    0F
S99_PLIST  DC  AL4(X'80000000'+S99_RB)
         SPACE 1
S99_RB   DC    AL1(S99RBEND-S99RB)
         DC    AL1(S99VRBUN)
         DC    AL1(S99NOMNT),AL1(0)
         DC    2AL2(0)
         DC    A(FREE_TUPL),2A(0)
*
*  Text Unit Pointers
*
          DS   0F
FREE_TUPL DC   AL4(0,X'80000000'+TU@DUNUNALC)
         SPACE 1
DAL_TUPL DC    A(TU@DALSTATS,0)
         SPACE 1
CONC_TUPL DC   AL4(0,X'80000000'+TU@DCCPERMC)
*
*  ALLOCATE Text Units
*
         DS    0F
* @DALDSNAM  DC  AL2(DALDDNAM),AL2(1),AL2(0),CL44' '
* @DALMEMBR  DC  AL2(DALMEMBR),AL2(1),AL2(0),CL8' '
TU@DALSTATS  DC  AL2(DALSTATS),AL2(1),AL2(1),X'08'
* @DALNDISP  DC  AL2(DALNDISP),AL2(1),AL2(1),X'08'
* @DALCDISP  DC  AL2(DALCDISP),AL2(1),AL2(1),X'08'
TU@DALRTDDN  DC  AL2(DALRTDDN),AL2(1),AL2(8),CL8' '
*
*  FREE Text Units
*
         DS    0F
TU@DUNUNALC  DC  AL2(DUNUNALC),AL2(0)
*
*  CONCATenate Text Units
*
         DS    0F
TU@DCCPERMC  DC  AL2(DCCPERMC),AL2(0)
         SPACE 2
RC_LIT   DC    C'RC'
         SPACE 2
HEX_TR   DC    10AL1(*-HEX_TR+C'0')
         DC    5AL1(*-10-HEX_TR+C'A')
         SPACE 2
MVC_TU   MVC   S99TUPAR(0),0(R3)
MVC_TUPAR MVC  TU_DATA(0),S99TUPAR
TRT_ARG  TRT   0(0,R3),TRTDSN
TRT_GDG  TRT   1(0,R14),TRTDSN
         SPACE 2
         LTORG
         TITLE            '<< REXX - Dynamic dataset allocation        X
                                                 DSECTs and EQUates >>'
GET_MAIN DSECT
SAVEAREA DS    18F
DBLWD    DS    D
         SPACE 1
LOCATE_OBTAIN  DS  0XL32
LOCATE_PLIST   DS  A
LOCATE@DSN     DS  A
               DS  A
LOCATE@WORK    DS  A
         SPACE 1
OBTAIN_PLIST   DS  A
OBTAIN@DSN     DS  A
OBTAIN@VOLSER  DS  A
OBTAIN@WORK    DS  A
         SPACE 2
BUILD_TUPL  DS 8A
         DS    0F
TU@___DDNAM  DS  3AL2
DDNAME   DS    CL8                 DDNAME definition is part of TU.
         SPACE 2
VOLSER   DS    CL6
         SPACE 2
CONCAT_COUNT   DS    H
         SPACE 2
DSN_LIST DS    16XL60
         SPACE 1
DD_LIST  DS    16XL10
         SPACE 1
TRTDSN   DS    XL256
         SPACE 1
DD_SW          DS    XL1
NULL           EQU   X'00'
CONCAT_FORCE   EQU   X'01'
@MEMBER        EQU   X'02'         Allocate a member member name.
FREE_FORCE     EQU   X'04'         FREE was requested.
CONDITIONAL    EQU   X'08'         Allocate only if not pre-alloacted.
COPY_DD        EQU   X'10'         Copy a DD allocation.
@VIO           EQU   X'20'         Do not LOCATE/OBTAIN (for VIO).
ALLOCATED      EQU   X'40'         DD was pre-alloacted.
         SPACE 1
         DS    0D
WORKAREA DS    0XL265
         DS    AL2
DEV_CODE DS    XL4
WA_VOLSER  DS  CL6
         DS    XL(265-12)
         DS    D
WORKLEN  EQU   *-GET_MAIN
         SPACE 2
         PRINT NOGEN
         YREGS
         SPACE 2
       IRXENVB
         SPACE 2
       IRXEXTE
         SPACE 2
       IRXSHVB
         SPACE 2
       IRXEFPL
         SPACE 2
      IRXARGTB
         SPACE 2
      IRXEVALB
         PRINT GEN
      IEFZB4D0
         SPACE 2
      IEFZB4D2
         SPACE 2
         PRINT NOGEN
        IHAPSA
         SPACE 2
        IKJTCB
         SPACE 2
      IEFTIOT1
         SPACE 2
      IEFJFCBN
         SPACE 2
         END  SCCALLOC
