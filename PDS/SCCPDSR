./ ADD NAME=$README  0100-01157-01157-1455-00038-00038-00000-PST0705
Installation / readme for SCCPDSR

There are 4 component for this package

ID.MAC  Is an Assembler macro required to assemble each of the assembler
        routines. Put it into a library included in your SYSLIB
        concatenation for the assemblies.

STSS384.ASM  Is an assembler subroutine required for SCCPDSR. Assemble
        it into an object or call library so that it can be link edited
        into SCCPDSR.  Note that this subroutine could be CALLed by any
        program wishing to read the records of a member in a PDS.

SCCPDSR.ASM  Is an assembler routine which runs as a Rexx function to
        populate a stem variable (or 'stack') with the member records

SCCPDSR.HLP  Is the documentation on how to access member records in
        Rexx

Making SCCPDSR available to your rexx program can be as simple as link
editing it to a load library that is within the JOBLIB/STEPLIB
concatenation when the rexx program runs. Myself, I have built a Rexx
function package under the name IRXFLOC which contains all the assembler
written rexx functions for the platform.

Below is a Rexx prototype to read all the records of every member from
DDname SYSUT1 where the member name begins with SCC. Note that DDname
SYSUT1 would be pre-allocated. SCCPDSD is another function packaged
separately.

Call SCCPDSD 'SYSUT1',   'SCC*',  'D.'
do d# = 1 to d.0
     call SCCPDSR 'SYSUT1',  left(d.d#,12),  'R.'
     do r# = 1 to r.0
          parse var r.r# word1 etc .
     end
     drop R.
end
./ ADD NAME=HELP     0100-01157-01157-1457-00075-00075-00000-PST0705
 Name:        SCCPDSR


 Purpose:     Read a specified member of a specified DDname into either
              a stemmed variable or into the data stack.

 Features:    Determination of ISRLEMX compression is made internally
              and decompression is performed automatically.

 Environment: REXX subroutine/function for all MVS/ESA environments.
              SCCPDSR resides in the IRXFLOC "function package".

 Arguments:
           1. The DDname of the library.

              The DDname must be pre-allocated to the library. That
              allocation must not be done at the member level.

           2. The name of the member within the library. If the entire
              directory entry (as per SCCPDSD) is available, then
              the first 12 bytes of the directory should be provided
              to SCCPDSR. See also argument 5.

           3. The name of the REXX stem variable to receive the
              records. The caller must ensure this specification is
              enclosed within quotes.

              If argument 3 is not specified (or specified as null),
              the records are placed in the data stack.

           4. (optional) The length of each record.hin the library.
              By default, 80 is used. If the member records are
              longer than 80 bytes, this argument must be spedcified
              to receive the entire record.

           5. (optional) The name of a variable which will be assigned
              the value of the directory entry associated with the
              member. The argument is redundant and ignored if argument
              2 is coded with TTR information.  The value of the
              directory entry will be formatted as per SCCPDSD; the
              function SPFDIR can be used to format an ISPF style entry
              in ebcdic values.

 Results: (when 'stem.' is specified at argument 3):
              'stem.0' contains a count of the number of records.

              'stem.1' through 'stem.stem.0' contains the individual
              records.

          (when argument 3 is null):
              The data stack contains records read in FIFO order.

          (independent of argument 3)
              As a REXX subroutine/function SCCPDSR must return a
              result to the caller. SCCPDSR returns a value indicative
              of internal errors. Typically this value is 000; if it
              is not all other results are suspect and incomplete.

              If the specified member name (argument 2) is not found in
              the concatenation of the directories, the result will be
              004.

 Notes:
    Choice of a technique to manage the 'data stack' is a subjective
    matter. SCCPDSR makes no choice. If the REXX program requires stack
    isolation, the programmer must use an appropriate technique.

    If SCCPDSR is used subsequent to the use of SCCPDSD against the same
    DDNAME and the DDNAME is a concatenation of multiple datasets with
    unhomoginous blocksizes, special action is required.  For such a
    situation, the allocation of the DDNAME must be such that the
    largest blocksize is associated with the first dataset in the
    concatenation either by coding a BLKSIZE parameter with the first
    dataset or by placing the dataset with the largest blocksize first
    in the concatenation.
./ ADD NAME=ID       0100-01157-01157-1459-00049-00049-00000-WSBG
         MACRO
&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY
         LCLC  &U,&LBL
.*
.* Stelco macro used to:
.*    - generate the CSECT statement.
.*    - generate the USING, AMODE and RMODE statements for the CSECT.
.*    - generate an eye-catcher and date/time stamp (28 bytes total).
.*      (The values for date and time are the time of the Assembly.)
.*
.* The default for the USING statement is (register) 15.
.* Other defaults are as per the prototype above.
.*
.* If the CSECT requires multiple base registers, their specification
.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)
.*
.* This macro can also be used to generate only the eye-catcher and
.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO
.*
.* -----------------------Modification History-------------------------
.* 98-02-19 change from &SYSDATE to &SYSDATC
.*
&U       SETC  '15'
&LBL     SETC  ' '
         AIF   (K'&LABEL EQ 0).LBLSET
&LBL     SETC  '&LABEL'
.LBLSET  ANOP
         AIF   (T'&USING EQ 'O').USET
         AIF   ('&USING'(1,1) NE '(').ONEUSE
&U       SETC  '&USING'(2,K'&USING-2)
         AGO   .USET
.ONEUSE  ANOP
&U       SETC  '&USING'
.USET    ANOP
         AIF   ('&CSECT' EQ 'YES').CSECT
&LBL     DS    0H
         B     *+32
         AGO   .STAMP
.CSECT   ANOP
&LBL     CSECT
&LBL     AMODE &AMODE
&LBL     RMODE &RMODE
         USING &LABEL,&U
         BC    15,32(,15)
.STAMP   ANOP
         DS    CL4
         DC    CL8'&LBL'
         DC    CL16'&SYSDATC &SYSTIME'
         MEND
./ ADD NAME=SCCPDSR  0100-01157-01157-1457-00620-00620-00000-PST0705
PDSR     TITLE            '<< REXX - Read a PDS Member                 X
                                                      Documentation >>'
* Name:        SCCPDSR
*
* Purpose:     Read all the records of a specified member of a
*              partitioned dataset via (Assembler) subroutine STSS384.
*
* Environment: REXX subroutine/function for Address TSO or MVS
*
* Features:    STSS384 supports decompression of ISRLEMX, WYLBUR and
*              YSLIM compressed members. For more information, refer
*              to STSS384's documentation.
*
*              The REXX caller receives the records through either:
*                 - a "stemmed" variable
*                 - the "data stack"
*
*              The REXX caller can specify a logical record length.
*
* Parameters:  1. The DDNAME which refers to the partitioned dataset.
*
*                 Note that the routine itself determines if the
*                 member has been compressed by ISRLEMX
*
*                 The following prefix values are reserved:
*                    YSLIM___ and WYL_____
*                 for referencing libraries where the members are
*                 YSLIM or WYLBUR compressed repectively.
*
*              2. The name of the member to be read. If the caller has
*                 entire directory entry available (as per SCCPDSD),
*                 the first 12 bytes of that entry should be provided.
*
*              3. (optional) The name of the stem variable which
*                 will be assigned the values from the record. If the
*                 caller does not delimit the stem with a period,
*                 one is generated.
*
*                 The REXX programmer should ensure that the value
*                 specified for the call is enclosed in quotes.
*
*                 stem.0 is assigned the value of the number of
*                 records read.
*
*                 If parameter 3 is not specified or specified as null,
*                 SCCPDSR places the records in the data stack.
*
*              4. (optional; omit unless required)
*                 The logical record length. More precisely
*                 the length of each record returned to the caller.
*
*                 This is the equivalent of   rec.1 = left(rec.1,n)
*
*                 When not specified, the logical record length of the
*                 dataset is used.
*
*              5. (optional; omit unless required)
*                 The variable name to receive the value of the
*                 directory entry associated with the member. The
*                 value will be in the same format as from SCCPDSD.
*
* Notes:
*    All the records of the member are read. The user should use
*    alternative techniques (e.g. EXECIO) to read selelective
*    records especially if the member contains many records.
*
*    There are mutually exclusive techniques to handle the data stack.
*    Since the choice of a technique is subjective, SCCPDSR makes no
*    choice. If stack isolation is required, an appropriate technique
*    is the responsibilty of the calling program.
         TITLE            '<< REXX - Read a PDS Member                 X
                                                     System Linkage >>'
         PRINT   GEN
SCCPDSR  ID    R12
         PRINT NOGEN
         SPACE 2
         STM   R14,R12,12(R13)
         LR    R12,R15
         ST    R13,SAVEAREA+4
         LA    R15,SAVEAREA
         ST    R15,8(,R13)
         LR    R13,R15
         XC    RC,RC
         B     MAINLINE
         SPACE 3
RC       DS    0F
         DS    AL1
RC1      DS    AL1
RC2      DS    AL1
RC3      DS    AL1
         SPACE 1
SAVEAREA DS    18F
         SPACE 3
RTNXT    DS    0H
         L     R13,SAVEAREA+4
         XC    8(4,R13),8(R13)
         XC    16(4,R13),16(R13)   R15 (return code) always
         LM    R14,R12,12(R13)        get set to zero.
         BR    R14
         TITLE            '<< REXX - Read a PDS Member                 X
                                                Parse the Arguments >>'
MAINLINE DS    0H
         USING EFPL,R1
         USING ENVBLOCK,R8
         USING IRXEXTE,R9
         USING EVALBLOCK,R11
         USING SHVBLOCK,R14
         LR    R8,R0               Address the environment block.
         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.
         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK.
         L     R11,0(,R11)
         MVI   TRTABLE-1,X'FF'     Pre-set table value.
         MVI   DDNAME,C' '
         MVC   DDNAME+1(L'DDNAME+L'MEMNAME+4-1),DDNAME
         XC    SET_REGS(4),SET_REGS
         XC    SHVNAMA-SHVBLOCK+@SHV,SHVNAMA-SHVBLOCK+@SHV
         NI    PLIST384,X'7F'      Ensure end-of-plist is OFF.
         LA    R0,LOCAL_BUFFER
         ST    R0,SHVVALA-SHVBLOCK+@SHV
         ST    R0,PLIST384+8
         OI    PLIST384+8,X'80'    Presume we will pass 3 args to 384.
         MVI   SW_384,DEFAULT_LEN
         BAL   R14,STRIP           Strip out arg(1).
         B     MISSING_DD          Arg(1) not specified.
         LA    R0,7                Maximum length.
         CR    R15,R0              Length(arg(1)) > maximum ?
         BNH   *+6                    -no -
         LR    R15,R0                 -yes-   Use maximum
         EX    R15,MVC_DD          Pick-up the DDname.
         SPACE 1
         BAL   R14,STRIP           Strip out arg(2).
         B     MISSING_MEM         Arg(2) not specified
         LA    R0,11               Maximum length.
         CR    R15,R0              Member name include TTR?
         BL    *+16                   -no -
         OI    SW_384,TTR@MEMBER   Say we have the TTR data.
         EX    R15,MVC_MEM         Pick-up the member name.
         B     GET_ARG3
         SPACE 1
         LA    R0,7                Maximum length.
         CR    R15,R0              Length(arg(2)) > maximum ?
         BNH   *+6                    -no -
         LR    R15,R0                 -yes-   Use maximum
         EX    R15,MVC_MEM         Pick-up the member name.
GET_ARG3 DS    0H
         BAL   R14,STRIP           Strip out arg(3).
         B     GET_ARG4            Arg(3) not specified
         LA    R5,6(,R15)          Maximum stem.tail length
         LA    R0,244              Maximum length of variable stem.
         SR    R0,R15              Calculate
         LA    R2,VAR_NAME            address where
         AR    R2,R0                     stem will be stored.
         CLI   0(R4),C'.'          Does stem end with period?
         BE    *+14                   -yes-
         LA    R5,1(,R5)              -no -   adjust length,
         BCTR  R2,0                              address and
         MVI   TAIL-1,C'.'                          provide the period.
         EX    R15,MVC_STEM        Pick-up the stem name.
         ST    R2,SHVNAMA-SHVBLOCK+@SHV
         ST    R5,SET_REGS+8       Now save (maximum) name length.
         SPACE 1
GET_ARG4 DS    0H
         BAL   R14,STRIP           Strip out arg(4).
         B     GET_ARG5            Arg(4) not specified
         LA    R0,14               Maximum length I can handle.
         CR    R15,R0              Too many digits?
         BH    BAD_LENGTH             -yes-
         LR    R0,R15              Hang onto the length.
         LA    R15,112(,R15)       Set lengths
         EX    R15,PACK1              to pack.
         UNPK  LOCAL_BUFFER(15),DBLWD   Undo that pack.
         LR    R15,R0              Calculate
         LA    R0,14                  how many
         SR    R0,R15                    (of 15)
         LA    R2,LOCAL_BUFFER              high order digits
         AR    R2,R0                           are insignificant.
         EX    R15,NUMERIC_TEST    Does unpacked result = original?
         BNE   BAD_LENGTH             -no -   i.e. not numeric
         OI    SW_384,USER_LEN
         CVB   R0,DBLWD            Requestor's
         ST    R0,SHVVALL-SHVBLOCK+@SHV  record length.
         C     R0,=F'256'
         BNH   GET_ARG5
       GETMAIN R,LV=(0)
         ST    R1,SHVVALA-SHVBLOCK+@SHV
         ST    R1,PLIST384+8
         OI    PLIST384+8,X'80'
GET_ARG5 DS    0H
         XC    SHVNAMA-SHVBLOCK+@SHV2,SHVNAMA-SHVBLOCK+@SHV2
         BAL   R14,STRIP
         B     CALL1
         NI    PLIST384+8,X'7F'
         ST    R3,SHVNAMA-SHVBLOCK+@SHV2
         LA    R15,1(,R15)
         ST    R15,SHVNAML-SHVBLOCK+@SHV2
         LA    R0,BLDL_LIST
         ST    R0,PLIST384+12
         OI    PLIST384+12,X'80'
         TITLE            '<< REXX - Read a PDS Member                 X
                      Call STSS384 and determine method of disposal >>'
CALL1    DS    0H
         LA    R1,PLIST384         Parameter list.
         L     R15,VSS384          Entry point address.
         TM    SW_384,TTR@MEMBER   User give me a TTR?
         BZ    *+8                    -no -
         L     R15,V@T2            Alternate entry point.
         SPACE 1
         BALR  R14,R15             Call.
         LTR   R15,R15             Success?
         BNZ   BAD_384                -no -
         TM    PLIST384+8,X'80'    Need to provide dirctory entry?
         BO    NO_DRCT1               -no -
         IC    R15,BLDL_LIST+13    Get
         N     R15,=F'31'             number of user halfwords
         SLL   R15,1                     as bytes
         LA    R15,14(,R15)                 plus fixed portion equals
         ST    R15,SHVVALL-SHVBLOCK+@SHV2      directory length.
         L     R15,IRXEXCOM        Get routine's address from vector.
         LA    R0,ENVBLOCK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM2
         BALR  R14,R15
NO_DRCT1 DS    0H
         L     R1,PLIST384+8       Get address
         L     R10,0(,R1)             of STSS384 member
         USING MEMNTRY0,R10              dsect and hence
         L     R2,MEMADCB-1                 the address of
         USING IHADCB,R2                       the DCB.
         LH    R0,DCBLRECL         Get the real LRECL.
         ST    R0,LRECL
         TM    SW_384,USER_LEN     Does caller want that LRECL?
         BO    *+8                       -no -
         ST    R0,SHVVALL-SHVBLOCK+@SHV  -yes-
         C     R0,SHVVALL-SHVBLOCK+@SHV  Is LRECL < callers request?
         BH    SET@384                      -yes-  deblk via STSS384.
         TM    MEMBER_SW,PACKED_MEMBER   Is the member ISRLEMX pressed.
         BO    LENGTH@384                   -yes-  deblk via STSS384.
         TM    DCBRECFM,DCBRECF    RECFM=F?
         BZ    *+8                    -no -
         OI    SW_384,DCBRECF         -yes-   Local reference
         TM    DCBRECFM,DCBRECV    RECFM=V?
         BZ    CALL384                -no-
         OI    SW_384,DCBRECV         -yes-   Local reference
         TM    SW_384,USER_LEN     Fixed output to caller?
         BO    LENGTH@384             -yes-
         LA    R0,SHVVALL-SHVBLOCK+@SHV  Tell STSS384 where to put
         ST    R0,PLIST384+12               record length.
         NI    PLIST384+8,X'7F'     Not 3
         OI    PLIST384+12,X'80'       but 4 args to STSS384.
         B     CALL384
LENGTH@384     DS    0H
         LA    R0,SHVVALL-SHVBLOCK+@SHV  Tell STSS384 where to put
         ST    R0,PLIST384+12               record length.
         NI    PLIST384+8,X'7F'     Not 3
         OI    PLIST384+12,X'80'       but 4 args to STSS384.
SET@384  DS    0H
         OI    SW_384,DEBLOCK@384   Deblocking is to be done @ STSS384.
         DROP  R2
CALL384  DS    0H
         TM    SW_384,DEBLOCK@384  Is STSS384 responsible for deblock?
         BO    CALL384@               -yes-
         TM    MEMBER_SW,DO_READ   Need a new block?
         BZ    DEBLOCK                -no -
         LA    R1,PLIST384         Parameter list.
         L     R15,VSS384          Entry point address.
         BALR  R14,R15             Call.
         L     R2,SHVNAMA-SHVBLOCK+@SHV
         LTR   R15,R15             Was non-normal condition raised?
         BNZ   @EOF
DEBLOCK  DS    0H
         L     R2,SHVNAMA-SHVBLOCK+@SHV When 0, stack instead of stem.
         L     R1,MEMAREC          Get address of logical record.
         TM    SW_384,DCBRECU      RECFM=U?
         BO    DEBLOCK_U              -yes-
         L     R0,LRECL            Get real LRECL.
         TM    SW_384,DCBRECV      RECFM=V?
         BZ    VALL_SET               -no -
         SR    R0,R0               Get
         ICM   R0,3,0(R1)             LRECL of this record
         S     R0,=F'4'                  reduce it by RDW length and
         LA    R1,4(,R1)                    step over the RDW.
         ST    R0,SHVVALL-SHVBLOCK+@SHV  Use the adjusted LRECL.
         B     VALL_SET
DEBLOCK_U  DS  0H
         LH    R0,MEMBLKL
         ST    R0,SHVVALL-SHVBLOCK+@SHV  Tell EXCOMM the value length.
VALL_SET DS    0H
         ST    R1,SHVVALA-SHVBLOCK+@SHV  Save address of logical record
         AR    R1,R0               Point to next logical record
         ST    R1,MEMAREC             and save that address.
         LH    R0,MEMBLKL          Calculate address of
         A     R0,MEMABLK             end-of-block.
         CR    R0,R1               Reached end-of-block?
         BH    STEM_OR_STACK          -no yet-
         OI    MEMBER_SW,DO_READ      -yes-   Indicate block READ req.
         B     STEM_OR_STACK       Go dispose of this record.
CALL384@ DS    0H
         TM    PLIST384,X'80'      Closing the DCB?
         BO    @384                   -yes-
         L     R15,SHVVALL-SHVBLOCK+@SHV
         L     R14,PLIST384+8
         LA    R14,0(,R14)
         LA    R1,1
         SLL   R1,30
         LR    R0,R14
         MVCL  R14,R0
@384     DS    0H
         LA    R1,PLIST384         Parameter list.
         LA    R15,VSTSS384        Top-of-list
         TM    SW_384,TTR@MEMBER   Caller provide a TTR'd member?
         BZ    *+8                    -no -
         LA    R15,8(,R15)            -yes- Use subset entry point
         TM    SW_384,DEBLOCK@384  Does STSS384 do the deblocking?
         BO    *+8                    -yes-
         LA    R15,4(,R15)            -no - Use alternate entry point.
         L     R15,0(,R15)         Entry point address.
         BALR  R14,R15             Call.
         TM    PLIST384,X'80'      Just closed the DCB?
         BO    SET_EOF                -yes-
         L     R2,SHVNAMA-SHVBLOCK+@SHV Get address of variable name.
         LTR   R15,R15             Did call complete normally?
         BZ    STEM_OR_STACK          -yes-
@EOF     DS    0H
         MVI   SW_384,DEBLOCK@384
         ST    R15,RC              Save the return code for inspection.
         CLI   RC3,12              End-of-file condition raised?
         BNE   READ_ERROR             -no -  There was an error.
         OI    PLIST384,X'80'      Tell STSS384 to close the DCB.
         LTR   R2,R2               Disposal via variable name?
         BZ    CALL384                -no -
         MVI   TAIL,C'0'           Will be setting stem.0
         L     R4,SET_REGS+8       Calculate
         S     R4,=F'4'               length of variable name and
         ST    R4,SHVNAML-SHVBLOCK+@SHV  tell EXCOM about it.
         L     R0,SET_REGS         Get the record count
         CVD   R0,DBLWD               into a
         UNPK  LOCAL_BUFFER(5),DBLWD+5(3)  ebcidic
         OI    LOCAL_BUFFER+4,X'F0'         format.
         LA    R4,5                Maximum value length.
         LA    R3,LOCAL_BUFFER     I start looking at the left.
         LA    R14,*+4             Top-of-loop address.
         CLI   0(R3),C'0'          High-order zero?
         BNE   *+10                   -no -  all set
         LA    R3,1(,R3)           Point to the next byte
         BCTR  R4,R14              Decrement value length and loop.
         SPACE 1
         ST    R3,SHVVALA-SHVBLOCK+@SHV  Address of the value.
         ST    R4,SHVVALL-SHVBLOCK+@SHV  Length of the value.
         B     CALL_EXCOM@
STEM_OR_STACK  DS   0H
         LTR   R2,R2
         BZ    STACK
         TITLE            '<< REXX - Read a PDS Member                 X
                            Build the tail of the stemmed variable. >>'
         LM    R2,R4,SET_REGS
         LA    R2,1(,R2)           Count the records and
         ST    R2,SET_REGS            save the count.
         CVD   R2,DBLWD            Covert the count
         UNPK  TAIL,DBLWD+5(3)        to ebcdic
         OI    TAIL+4,X'F0'              format.
         CLI   TAIL,C'0'           Any high-order zero?
         BNE   BIG_TAIL               -no -   That was easy.
         LA    R14,*+4             Top-of-loop address.
         SPACE 1
         CLI   0(R3),C'0'          (still) a high-order zero?
         BNE   *+10                   -no -   Exit the loop.
         LA    R3,1(,R3)           Point to next byte.
         BCTR  R4,R14              Decrement name length and loop.
         SPACE 1
         MVC   TAIL,0(R3)
BIG_TAIL DS    0H
         ST    R4,SHVNAML-SHVBLOCK+@SHV
         TITLE            '<< REXX - Read a PDS member                 X
                Assign the value from the record to a REXX variable >>'
CALL_EXCOM  DS  0H
*
* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
CALL_EXCOM@    DS  0H
         L     R15,IRXEXCOM        Get routine's address from vector.
         LA    R0,ENVBLOCK         Make sure REXX knows environment.
         LA    R1,PLIST_EXCOM
         BALR  R14,R15
         B     CALL384
         SPACE 1
PLIST_EXCOM DC A(EXCOM_LIT,0,0)
         DC    A(@SHV+X'80000000')
         SPACE 1
@SHV     DS    0A
         DC    2A(0)
         DC    C'S'
         DS    XL3'000000'
         DC    A(0,0,0,LOCAL_BUFFER,0)
         SPACE 1
PLIST_EXCOM2   DC     A(EXCOM_LIT,0,0)
         DC    A(@SHV2+X'80000000')
         SPACE 1
@SHV2    DS    0A
         DC    2A(0)
         DC    C'S'
         DS    XL3'000000'
         DC    A(0,0,0,BLDL_LIST,0)
         SPACE 1
EXCOM_LIT DC   CL8'IRXEXCOM'
         TITLE            '<< REXX - Read a PDS member                 X
                     Subroutine to Strip Leading && Trailing Blanks >>'
* Registers upon entry
*    R10 ==> argument table entry
*    R14 ==> exit address when agrument is null
*    R14+4=> normal exit
*
* Registers upon exit
*    R10 ==> next argument table entry.
*    R2    = 0 (zero)
*    R3  ==> leftmost non-blank byte of argument
*    R4  ==> rightmost non-blank byte of argument
*    R15   = R4 - R3 (length of argument minus 1)
         SPACE 2
HEXFF    DC    X'FFFFFFFFFFFFFFFF'
         DS    XL1
TRTABLE  DS    XL256
         SPACE 1
TRT3     TRT   0(0,R3),TRTABLE
         SPACE 2
         USING ARGTABLE_ENTRY,R10
STRIP    DS    0H
         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?
         BER   R14                              -no -
         L     R15,ARGTABLE_ARGSTRING_LENGTH
         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.
         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.
         SPACE 1
         LTR   R15,R15             Does the argument have any length?
         BZR   R14                    -NO - take abnormal exit.
         LA    R4,0(R15,R3)        Point just beyond ARG.
         MVC   TRTABLE,TRTABLE-1   Set to
         MVI   TRTABLE+C' ',X'00'     bypass blanks.
         BCTR  R15,0               Set length for TRT instruction.
         EX    R15,TRT3            Skip to non-blank.
         BZR   R14                 When all blank.
         LR    R3,R1               Re-set starting address.
STRIP@R  DS    0H
         BCTR  R4,0                Backpedal 1 byte.
         CLI   0(R4),X'40'         (still) at a blanK?
         BNE   STRIPPED               -no -
         CR    R4,R3                  -yes-  More to inspect?
         BH    STRIP@R                          -yes-
STRIPPED DS    0H
         LR    R15,R4              Calculate
         SR    R15,R3                 length of ARG - 1.
         SR    R2,R2               Pre-clear R2 for TRT
         XC    TRTABLE,TRTABLE     Clear translate table.
         BC    15,4(,R14)          Take normal exit.
         TITLE            '<< REXX - Read a PDS Member                 X
                                   Put the record on the data stack >>'
*
* Refer to the IRXSTK   routine; pages 485-490 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
STK_FUNC DC    CL8'QUEUE   '
STK_PLIST  DC  A(STK_FUNC)
         DC    A(SHVVALA-SHVBLOCK+@SHV)
         DC    A(SHVVALL-SHVBLOCK+@SHV)
         DC    A(RC+X'80000000')
         SPACE 2
STACK    DS    0H
         LA    R1,STK_PLIST
         LA    R0,ENVBLOCK
         L     R15,IRXSTK
         BALR  R14,R15
         B     CALL384
         TITLE            '<< REXX - Read a PDS Member                 X
                                                   Error Conditions >>'
*
* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -
* TSO Extentions Version 2  REXX/MVS Reference
*
SAY_LIT        DC    CL8'WRITE   '
SAY_BUFF       DS    A
SAY_LEN        DS    F
SAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')
MISSING_DD_MSG DC    C'First argument (DDNAME) missing.'
MISSING_MEM_MSG DC   C'Second argument (member name) missing.'
BAD_LENGTH_MSG DC    C'Fourth argument not numeric or too large.'
BAD_384_MSG    DC    C'Error in STSS384. Check ''result''.'
               SPACE 2
MISSING_DD     DS    0H
         LA    R15,MISSING_DD_MSG
         LA    R0,L'MISSING_DD_MSG
         B     SAY_CALL
MISSING_MEM    DS    0H
         LA    R15,MISSING_MEM_MSG
         LA    R0,L'MISSING_MEM_MSG
         B     SAY_CALL
BAD_LENGTH     DS    0H
         LA    R15,BAD_LENGTH_MSG
         LA    R0,L'BAD_LENGTH_MSG
         B     SAY_CALL
SAY_CALL DS    0H
         ST    R15,SAY_BUFF
         ST    R0,SAY_LEN
         LA    R1,SAY_PLIST
         LA    R0,ENVBLOCK
         L     R15,IRXSAY
         BALR  R14,R15
         L     R13,SAVEAREA+4
         XC    8(4,R13),8(R13)
         LM    R14,R12,12(R13)
         LA    R15,40
         BR    R14
         SPACE 2
BAD_384  DS    0H
         CVD   R15,DBLWD           Convert the return code.
         LA    R0,BAD_384_MSG
         ST    R0,SAY_BUFF
         LA    R0,L'BAD_384_MSG
         ST    R0,SAY_LEN
         LA    R1,SAY_PLIST
         LA    R0,ENVBLOCK
         L     R15,IRXSAY
         BALR  R14,R15
         B     SET_RC
         TITLE            '<< REXX - Read a PDS Member                 X
                                                 Exits back to REXX >>'
SET_EOF  DS    0H
         LA    R15,0
READ_ERROR DS  0H
         CVD   R15,DBLWD           Convert the return code
SET_RC   DS    0H
         UNPK  EVALBLOCK_EVDATA(3),DBLWD+6(2)  into
         OI    EVALBLOCK_EVDATA+2,X'F0'         ebcidic format.
         LA    R2,3                Length of the return code is 3.
         ST    R2,EVALBLOCK_EVLEN  Let REXX know the length.
         SPACE 2
         L     R0,SHVVALL-SHVBLOCK+@SHV  The length of the values
         C     R0,=F'256'                   to see if we did a GETMAIN.
         BNH   RTNXT               No we didn't.
         L     R1,SHVVALA-SHVBLOCK+@SHV Area to be freed.
      FREEMAIN R,LV=(0),A=(1)
         B     RTNXT               All done.
         TITLE            '<< REXX - Read a PDS Member                 X
                                              Global Data Constants >>'
         SPACE 2
DBLWD    DS    D
         SPACE 2
SET_REGS DC    A(0,TAIL,0)
         SPACE 1
VSTSS384 DC    V(STSS384)
VSS384   DC    V(SS384)
V@T1     DC    V(SS384@T1)
V@T2     DC    V(SS384@T2)
         SPACE 1
PLIST384 DC    A(DDNAME,MEMNAME,LOCAL_BUFFER+X'80000000',0)
DDNAME   DC    CL8' '
MEMNAME  DC    CL8' '
         DS    CL4                 Reserved for TTR data.
MVC_DD   MVC   DDNAME(0),0(R3)
MVC_MEM  MVC   MEMNAME(0),0(R3)
MVC_STEM MVC   0(0,R2),0(R3)
PACK1    PACK  DBLWD(0),0(0,R3)
NUMERIC_TEST   CLC   0(0,R3),0(R2)
         SPACE 2
VAR_NAME DS    0CL250
         DS    CL245
TAIL     DS    CL5
         SPACE 2
SW_384   DC      X'00'
DEFAULT_LEN    EQU   X'00'
USER_LEN       EQU   X'01'
DEBLOCK@384    EQU   X'08'
TTR@MEMBER     EQU   X'10'
         SPACE 2
         DS    0D
         DC    CL8' '
LOCAL_BUFFER   DS    0CL256
         DS    F
LRECL    DS    F
         DS    CL248               248 = 256-(*-LOCAL_BUFFER)
         SPACE 2
BLDL_LIST      DS    CL60
         SPACE 2
         LTORG
         TITLE            '<< REXX Read a PDS member record            X
                                                 DSECTs and EQUates >>'
         YREGS
         SPACE 2
       IRXENVB
         SPACE 2
       IRXEXTE
         SPACE 2
       IRXSHVB
         SPACE 2
       IRXEFPL
         SPACE 2
      IRXARGTB
         SPACE 2
      IRXEVALB
         SPACE 2
         DCBD  DSORG=(PO),DEVD(DA)
         SPACE 2
MEMNTRY0 DSECT
MEMNAME0 DS    CL8
         DS    2A
         DS    AL1
MEMADCB  DS    AL3
MEMABLK  DS    F
         DS    AL1
         DS    AL3
MEMAREC  DS    F
         DS    F
MEMBLKL  DS    H
MEMBER_SW      DS    XL1
NEW_MEMBER     EQU  X'80'
PACKED_MEMBER  EQU  X'40'
OVERFLOW       EQU  X'20'
DE_ACTIVE      EQU  X'08'
DO_READ        EQU  X'04'
         DS    0D
MEMNTRY  EQU   *-MEMNAME0
         END   SCCPDSR
./ ADD NAME=STSS384  0100-01157-01157-1457-00827-00827-00000-PST0705
SS384    TITLE                     'Read PDS member(s)                 x
                                                         Documentation'
* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *
*
* Program name :  STSS384
*
* Function:       Get the next logical record from a library member.
*                 The "get" process will include explosion of
*                 compressed data for ISPF, WYLBUR and YSLIM depending
*                 on the value of the DDNAME specified with the CALL.
*
*                 Note that a caller can have multiple members in
*                 process simultaneously.
*
* Parameters:  1. The DDNAME representing the library of the member.
*                 The values of   WYLn   and   YSLIMn
*                 have special meaning in that they must be used to
*                 to decompress WYLBUR or YSLIM members.
*
*              2. (optional) Member name within the library that is to
*                 be read. If not specified, the areas associated with
*                 specfied DDname are released/closed.
*
*              3. (required unless parameter 2 is not specified.)
*                 Area where the read data is to be placed.
*
*              4. (optional) Fullword to receive the length of the
*                 record.
*
* Entry points    The 4 entry points are used for the 4 combinations
*                 of whether or not the member name includes TTR data
*                 and whether or not this routine is responsible for
*                 de-blocking the data.
*
*                 De-block here?   TTR data with member?
*
*         STSS384     yes             no
*         SS384       no              no
*         SS384@T1    yes             yes
*         SS384@T2    no              yes
*
*
* Updates:
*     Feb. 1995  - Include decompression of ISPF packed data.
*     R. Ryerse
*
*     Jun. 1995  - Ensure AMODE 31 (after FIND macro).
*     R. Ryerse  - Make parameter 2 optional; include close of DCB.
*
*     Jul. 1995  - Remove limitation of DDNAME values.
*     R. Ryerse  - Build the DCBs dynamically (below the line).
*                - Repair tests for DCBRECV.
*                - Add entry point SS384.
*                - Research RMODE=ANY
*                - Incorporate use of parameter 4
*
*     Dec. 1995  - Include ENTRY points and remove call to STSS383. By
*                  excluding STSS383, use of the FIND macro now depends
*                  on whether or not the caller provides TTR data with
*                  the member name. With TTR data a type C FIND is
*                  used, without TTR data a type D FIND is used.
* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *
         TITLE                     'Read PDS member(s)                 x
                                               Initialization per call'
         PRINT NOGEN
*
* RMODE=24 is required. If STSS384 were to execute above the line,
* the routines referenced off the DCB (FIND, READ, CHECK) will
* not return. They switch to AMODE=24 and don't switch back.
*
STSS384  ID    R12,AMODE=31,RMODE=24
         USING IHADCB,R10
         USING DDNTRY0,R6
         USING MEMNTRY0,R2
         USING FREENTRY,R4
         ENTRY SS384
         ENTRY SS384@T1
         ENTRY SS384@T2
         STM   R14,R12,12(R13)
         LR    R12,R15
         ST    R13,SAVEAREA+4
         LA    R15,SAVEAREA
         ST    R15,8(,R13)
         LR    R13,R15
         MVI   ENTRY_SW,YES_DEBLOCK
         B     START
         SPACE 2
SS384    DS    0F
         DROP  R12
         USING *,R15
         STM   R14,R12,12(R13)
         L     R12,VSTSS384
         DROP  R15
         USING STSS384,R12
         ST    R13,SAVEAREA+4
         LA    R15,SAVEAREA
         ST    R15,8(,R13)
         LR    R13,R15
         MVI   ENTRY_SW,NO_DEBLOCK
         B     START
         SPACE 2
SS384@T1 DS    0F
         DROP  R12
         USING *,R15
         STM   R14,R12,12(R13)
         L     R12,VSTSS384
         DROP  R15
         USING STSS384,R12
         ST    R13,SAVEAREA+4
         LA    R15,SAVEAREA
         ST    R15,8(,R13)
         LR    R13,R15
         MVI   ENTRY_SW,YES_DEBLOCK+TTR_MEMBER
         B     START
         SPACE 2
SS384@T2 DS    0F
         DROP  R12
         USING *,R15
         STM   R14,R12,12(R13)
         L     R12,VSTSS384
         DROP  R15
         USING STSS384,R12
         ST    R13,SAVEAREA+4
         LA    R15,SAVEAREA
         ST    R15,8(,R13)
         LR    R13,R15
         MVI   ENTRY_SW,NO_DEBLOCK+TTR_MEMBER
         B     START
         SPACE 2
VSTSS384 DC    V(STSS384)
SAVEAREA DS    18F
         SPACE 1
FULLRC   DS    0F
         DC    XL3'000000'
RC       DC    X'00'
         SPACE 3
RTNXT    DS    0H
         L     R15,FULLRC
         L     R13,SAVEAREA+4
         XC    8(4,R13),8(R13)
         L     R14,12(,R13)
         LM    R0,R12,20(R13)
         BR    R14
         TITLE                     'Read PDS member(s)                 x
                                                      Match/set DDNAME'
START    DS    0H
         ST    R1,APARMS             Save my plist address.
         XC    FULLRC,FULLRC         Pre-clear my return code.
         LM    R3,R5,0(R1)           Address callers 3 parameters.
         LA    R5,0(,R5)             Clear high order bit.
         LA    R6,DDTBL-DDNTRY       Get ready to search DD entries.
FIND_DDNAME DS 0H
         LA    R6,DDNTRY(,R6)        Point to next DD entry.
         CLC   DDNAME0,0(R3)         Matched the caller's DDname?
         BE    OPENED                   -yes-
         CLC   DDNAME0,BLANK15       Any more DD entries?
         BE    BUILD_DCB                -no - Build a new entry
         C     R6,=A(DDLAST)         At the end of the DD table?
         BL    FIND_DDNAME              -not yet-   Keep looking.
         WTO   MF=(E,ABNDMSG1)
         ABEND 384,DUMP,STEP
ABNDMSG1 DS    0F
         DC    AL2(MSG1L),XL2'8000',C'STSS384  :  '
         DC    C'Too many DDnames.'
MSG1L    EQU   *-ABNDMSG1
         DC    X'04000020'
         SPACE 1
BUILD_DCB  DS  0H
         ST    R6,LAST_DD_ENTRY     Remember what entry I am at.
         MVC   DDNAME0,0(R3)        Get the DDname.
         LA    R0,DCBLNGPO          How much space we need
       GETMAIN RU,LV=(0),LOC=BELOW     to hold the DCB
         LR    R10,R1               Base register for DCB
         ST    R10,DDADCB0          Save that address in the DD entry.
         MVC   IHADCB(DCBLNGPO),A_DCB   Copy the DCB.
         MVC   DCBDDNAM,DDNAME0     Use the caller's DDname.
         CLC   =CL5'YSLIM',DDNAME0  Special DDname?
         BE    SET_RECFM@U             -yes-
         CLC   =CL3'WYL',DDNAME0    Special DDname?
         BE    SET_RECFM@U             -yes-
         B     *+8                     -no -
SET_RECFM@U DS 0H
         MVI   DCBRECFM,DCBRECU     Special DDnames are RECFM=U.
         OPEN  ((R10)),MODE=31
*        MVI   DCBKEYLE,0
         B     NEWMEM
CLOSE    DS    0H
         LH    R15,DCBBLKSI         Use blocksize
         LA    R15,15(,R15)            to calculate
         SRL   R15,3                      amount
         SLL   R15,3                         of storage
         LR    R0,R15                           for FREEMAIN's.
         LA    R4,DDAFREE           Anchor the chain.
FREE_LOOP  DS  0H
         L     R4,FREENXT           Another
         LTR   R4,R4                   link?
         BZ    CLOSE_DCB                 -no -
         L     R2,FREEADDR          Get address to be freed.
         XC    FREEADDR,FREEADDR    Make the entry available.
*  Note that FREENXT is not cleared; without an anchor
*  the link (address) is meaningless. The anchor is released below.
      FREEMAIN R,LV=(R0),A=(R2)
         B     FREE_LOOP            Go get next link in the chain.
         SPACE 1
CLOSE_DCB  DS  0H
         CLOSE ((R10)),MODE=31
         LA    R0,DCBLNGPO
      FREEMAIN R,LV=(R0),A=(R10)
         L     R1,LAST_DD_ENTRY      Is this
         CR    R1,R6                    the last DD table entry?
         BE    *+12                        -yes-
         MVC   DDNTRY0(DDNTRY),0(R1)       -no - last entry goes here
         LR    R6,R1                                and switch.
         SPACE 1
         XC    DDNTRY0(DDNTRY),DDNTRY0
         MVC   DDNAME0,BLANK15       Clear the last DD table entry.
         B     RTNXT                 All done.
         TITLE                     'Read PDS member(s)                 x
                                                 Match/set member name'
OPENED   DS    0H
         L     R10,DDADCB0           Get the DCB address.
         TM    0(R1),X'80'           Caller requesting 'close'?
         BO    CLOSE                    -yes- Honor the request.
         LA    R2,MEMTBL             Point to 1st member table entry.
         CLC   MEMNAME0,0(R4)        Right member name?
         BNE   MEMATCH                  -no -
         SR    R0,R0                 Get
         ICM   R0,7,MEMADCB             DCB address for this entry.
         CR    R10,R0                Right DCB
         BE    ALLMATCH                 -yes-  We have the right entry.
MEMATCH  DS    0H
         LA    R2,MEMNTRY(,R2)       Point to next member entry.
         CLC   MEMNAME0,0(R4)        Right member name?
         BNE   *+16                     -no -
         SR    R0,R0                 Get
         ICM   R0,7,MEMADCB             DCB address for this entry.
         CR    R10,R0                Right DCB
         BE    ALLMATCH                 -yes-  We have the right entry.
         SPACE 1
         C     R2,=A(MEMLAST)        At last table entry?
         BL    MEMATCH                  -not yet-  keep looping
         SPACE 2
NEWMEM   DS    0H
MEMHIT   DS    0H
         LA    R2,MEMTBL-MEMNTRY
         LA    R2,MEMNTRY(,R2)
         CLI   MEMBER_SW,DE_ACTIVE
         BE    MEM2TBL
         C     R2,=A(MEMLAST)
         BL    MEMHIT+4
         WTO   'STSS384  :  No room in member name table. Run aborted',x
               ROUTCDE=(11),DESC=(6)
         ABEND 384,DUMP,STEP
MEM2TBL  DS    0H
         ST    R4,SAVE25+8          Save R4.
         LA    R4,DDAFREE           Get 'free chain' anchor.
         L     R1,FREENXT           Is the
         LTR   R1,R1                   chain anchored?
         BP    MEM2TBL2                   -yes-  Go find the last link.
         LH    R15,DCBBLKSI         Use blocksize
         LA    R15,15(,R15)            to calculate
         SRL   R15,3                      amount
         SLL   R15,3                         of storage
         LR    R0,R15                           for GETMAIN.
       GETMAIN R,LV=(0),LOC=BELOW
         B     GOTMAIN
MEM2TBL2 DS    0H
         LR    R0,R4                Address of previous link.
         LR    R4,R1                Step along. (R1 already loaded.)
         L     R1,FREENXT           Another
         LTR   R1,R1                   link yet?
         BP    MEM2TBL2                   -no -  keep looking.
         L     R1,FREEADDR          Use GETMAIN'd address.
         XC    FREEADDR,FREEADDR       but make it unavailable.
         LR    R4,R0                Drop
         XC    FREENXT,FREENXT         the last link.
GOTMAIN  DS    0H                   Build table entry for the member.
         L     R4,SAVE25+8
         XC    MEMDECB,MEMDECB      Pre-clear the DECB
         MVC   MEMNAME0,0(R4)       Member name
         MVI   MEMBER_SW,DO_READ+NEW_MEMBER  (DECB) READ types
         LA    R1,0(,R1)
         ST    R1,MEMABLK           (DECB) data address
         TM    ENTRY_SW,TTR_MEMBER
         BZ    FIND@D
         LA    R0,8(,R4)
*        FIND  (R10),(R0),C
         MVC   DCBRELAD,8(R4)
FIND@C   DS    0H
         LR    R1,R10
         LR    R0,R10
         SR    R15,R15
         ICM   R15,7,DCBCNTRL+1
         BAL   R14,4(0,R15)
         L     R14,AMODE31
         BSM   0,R14
FIND@D   DS    0H
         TM    ENTRY_SW,NO_DEBLOCK Do I do the deblocking?
         BZ    FIND@D1                -no -   Don't do BLDL
         L     R1,APARMS           Did caller provide
         TM    8(R1),X'80'            more than 3 parms?
         BO    FIND@D1                   -no -   Don't do BLDL
         PRINT GEN
         L     R11,12(,R1)         Get address of parm 4.
         LA    R0,1                Need 1
         STH   R0,0(,R11)             as value for BLDL FF field.
         LA    R0,58               Need 58
         STH   R0,2(,R11)             as value for BLDL LL field.
         MVC   4(8,R11),MEMNAME0
         LR    R0,R11              R0 as list address.
         LA    R1,0(,R10)          R1 as DCB address.
*        BLDL  (1),(0)             Get the directory entry.
         SLR   R15,R15
         SVC   18
         L     R14,AMODE31
         LTR   R15,R15             Success?
         BZ    *+6                    -yes-
         BSM   0,R14                  -no -
         MVC   0(58,R11),4(R11)    Drop prefix from BLDL list.
         MVC   DCBRELAD,8(R11)     Preamble of FIND type "C".
         B     FIND@C
FIND@D1  DS    0H
*        FIND  (R10),(R4),D
         LCR   R1,R10
         LR    R0,R4
SVC18    DS    0H
         SVC   18
         PRINT NOGEN
         L     R14,AMODE31
         BSM   0,R14
AMODE31  DC    A(AMODE31+X'80000004')
         LTR   R15,R15
         BZ    ALLMATCH
         ST    R15,FULLRC
         CVD   R15,DBLWD
         MVC   WARN1RC,=X'40202120'
         ED    WARN1RC,DBLWD+6
         WTO   MF=(E,WARN1MSG)
         B     RTNXT
         TITLE                     'Read PDS member(s)                 x
                                                          Read (PIOCS)'
ALLMATCH DS    0H
         TM    MEMBER_SW,DO_READ     (Physical) read required?
         BZ    DEBLOCK                  -no - Go get data from buffer.
         NI    MEMBER_SW,255-DO_READ Turn off the indicator.
READ     DS    0H
         LA    R7,MEMDECB            Address
         USING DECB,R7                  the DECB.
         MVI   DECTYPE1,DECLNS       Set the
         MVI   DECTYPE2,DECRDSF         DECB type.
         ST    R10,DECDCBAD          Put the DCB address into the DECB.
         LR    R1,R7                 R1 = A(DECB)
         SR    R15,R15               Make sure high-order byte is clear
         ICM   R15,7,DCBREADA           for the READ address
         BALR  R14,R15               READ (completed by CHECK below.)
         LR    R1,R7                 R1 = A(DECB)
         SR    R15,R15               Make sure high-order byte is clear
         ICM   R15,7,DCBCHCKA           for CHECK address.
         BALR  R14,R15               CHECK completes READ.
         L     R9,DECIOBPT           Address
         USING IOBSTDRD,R9              the IOB.
         LH    R1,DCBBLKSI           BLKSIZE
         SH    R1,IOBCSW+5              minus short fall
         STH   R1,MEMBLKL                  equals size of the block.
         DROP  R9
         DROP  R7
         L     R1,MEMABLK            Address of the block.
         TM    DCBRECFM,DCBRECU      RECFM=U?
         BO    *+16                     -yes-
         TM    DCBRECFM,DCBRECV      RECFM=V?
         BZ    *+8                      -no -
         LA    R1,4(,R1)                -yes- step over block length.
         ST    R1,MEMAREC            Address of (1st) record.
         TITLE                     'Read PDS member(s)                 x
                                What type of deblocking is to be used?'
         TM    MEMBER_SW,OVERFLOW    Handling a buffer wrap?
         BZ    NOT_FLOWING              -no -
         L     R7,MEM_FLOWAREA       Address of iterim area.
         L     R9,0(,R7)             Get length of interim area.
         L     R14,4(,R7)            Length already used
         LA    R14,8(,R14)              plus 8
         SR    R9,R14                      subtracted from total length
         BCTR  R9,0                  Fill the interim area
         EX    R9,NEWFLOW               from the new buffer.
         LR    R8,R7                 Calculate
         A     R8,0(,R7)                "dummy" end-of-buffer address.
         LH    R0,DCBLRECL           Calculate
         AR    R0,R5                    end-of take-up address.
         SR    R1,R1                 Needs to be clear.
         LA    R7,8(,R7)             Address of data to be unpacked.
         B     UNPACK                Unpack the interim area.
NEWFLOW  MVC   0(0,R8),0(R1)
         SPACE 1
NOT_FLOWING  DS  0H
         TM    MEMBER_SW,PACKED_MEMBER  Are we (already) unpacking?
         BZ    *+12                        -no -
         LA    R7,0(,R1)                   -yes- Get data address and
         B     SET_E_O_B                            go unpack.
         SPACE 1
         TM    MEMBER_SW,NEW_MEMBER  Just read 1st block?
         BZ    DEBLOCK                  -no -
         NI    MEMBER_SW,255-NEW_MEMBER  Turn off 1st read indicator.
         CLC   =CL3'WYL',DDNAME0     Reading a 'normal' PDS?
         BE    DEBLOCK                  -no -
         CLC   =CL5'YSLIM',DDNAME0   Reading a 'normal' PDS?
         BE    DEBLOCK                  -no -
         TM    DCBRECFM,DCBRECV      RECFM=V?
         BZ    *+8                      -no -
         LA    R1,8(,R1)                -yes- Get address of data.
         CLC   =XL3'000140',0(R1)    Is member packed?
         BNE   DEBLOCK                  -no -
         OI    MEMBER_SW,PACKED_MEMBER  Indicate packed member.
         LH    R8,6(,R1)             Get lrecl as per packing.
         LA    R8,8+8(,R8)           8 bytes for my areas plus 8 more
*                                       for inserted control bytes.
         LA    R1,8(,R1)             Bypass the header information and
         ST    R1,MEMAREC               save the data address.
         SRL   R8,3
         SLL   R8,3
         LR    R0,R8
       GETMAIN R,LV=(R0),LOC=BELOW
         ST    R1,MEM_FLOWAREA
         ST    R8,0(,R1)
         SPACE 1
DEBLOCK  DS    0H
         TM    ENTRY_SW,NO_DEBLOCK   Caller want blocked data?
         BZ    *+12                     -no -
         ST    R2,0(,R5)                -yes-   Give the mem tbl ntry
         B     RTNXT                               and exit
         L     R7,MEMAREC            Get address of data (source).
         CLC   =CL3'WYL',DDNAME0     WYLBUR dataset?
         BE    WYLBLK                   -yes-   special handling.
         CLC   =CL5'YSLIM',DDNAME0   YSLIM dataset?
         BE    YSLIMBLK                 -yes-   specila handling.
         TM    MEMBER_SW,PACKED_MEMBER  Packed member?
         BZ    NOT_PACKED                  -no -
         TITLE                     'Read PDS member(s)                 x
                                                       (PDF) Unpacking'
SET_E_O_B  DS  0H
         LR    R8,R5                 Calculate
         AH    R8,DCBLRECL               end-of-record address.
         CLI   0(R7),X'FF'           End-of-member?
         BE    EOMEM                    -yes-
         LR    R0,R8                 Use R0 for end-of-output address.
         L     R8,MEMABLK            Calculate address of
         AH    R8,MEMBLKL               the end of the block.
         SR    R1,R1                 Clear a work register.
UNPACK   DS    0H
         CR    R7,R8                 At end-of-block?
         BL    UNPACK1                  -not yet- Keep unpacking.
         BH    START_WRAP               -beyond - Buffer wrapping.
         CR    R0,R5                 At end of (output) record?
         BH    START_WRAP               -not yet- Buffer wrapping.
         ST    R7,MEMAREC               -yes-  Save data address and
         B     DEBLKXT                            exit deblocking
START_WRAP  DS  0H
         OI    MEMBER_SW,OVERFLOW    Need an 'buffer wrap' indicator.
         LR    R5,R0                 Point to
         SH    R5,DCBLRECL              caller's receiving area.
         L     R1,MEM_FLOWAREA       Get address of interim area.
         L     R9,MEMAREC            Re-do for entire logical record.
         SR    R8,R9                 How much in the exhausted buffer.
         ST    R8,4(,R1)             Save that length.
         BCTR  R8,0                  Move the residual
         EX    R8,OLDFLOW               from the exhauted buffer.
         LA    R8,9(R1,R8)           Data from new buffer goes here.
         B     READ                  Go read next buffer.
OLDFLOW  MVC   8(0,R1),0(R9)
UNPACK1  DS    0H
         CR    R0,R5                 At end of (output) record?
         BH    *+12                     -not yet-
         ST    R7,MEMAREC               -yes-  Save data address and
         B     DEBLKXT                            exit deblocking
         SPACE 1
         IC    R1,0(,R7)             Get instruction length
         N     R1,=F'127'               never > 127
*
         CLI   0(R7),X'7A'           At a repeating character?
         BNE   NOT_REPEATER             -no -
         LA    R14,3(,R7)            Address of next area to unpack.
         CR    R14,R8                Beyond the end of the buffer?
         BH    START_WRAP               -yes-
         IC    R1,1(,R7)             Get repetition count and
         MVC   0(1,R5),2(R7)            repeating character.
         LR    R7,R14                Point to next (source) data.
DUPLICATE  DS  0H
         BCTR  R1,0                  Get instr. len. from rept'n
         EX    R1,REPEATER           Repeat the character.
         LA    R5,2(R1,R5)           Point to next receiver addr.
         B     UNPACK                Loop back
REPEATER MVC  1(0,R5),0(R5)
         SPACE 1
NOT_REPEATER  DS 0H
         CLI   0(R7),X'7C'           End-of-record indicator?
         BNE   NOT_END_OF_REC           -no -
         TM    DCBRECFM,DCBRECF      RECFM=F?
         BO    NOT_DATA                 -yes-
         LR    R0,R5                 Indicate end-of-record.
         LA    R7,1(,R7)             Point at next source data.
         B     UNPACK                Loop back.
         SPACE 1
NOT_END_OF_REC  DS   0H
         TM    0(R7),X'80'           Data to be move?
         BZ    NOT_DATA                 -no -
         LA    R14,2(R1,R7)          Address of next area to unpack.
         CR    R14,R8                Beyond the end of the buffer?
         BH    START_WRAP               -yes-
         EX    R1,SIMPLE_MOVE        Move that chunk.
         LA    R5,1(R1,R5)           Re-set target address.
         LR    R7,R14                Re-set source address.
         B     UNPACK                Loop back.
SIMPLE_MOVE MVC  0(0,R5),1(R7)
         SPACE 1
NOT_DATA DS    0H
         MVI   0(R5),X'40'           Must be padding with blanks.
         CLI   0(R7),X'00'           One byte of space?
         LA    R7,1(,R7)                -anyway- Re-set source address.
         BNE   DUPLICATE                -no    - Duplicate
         LA    R5,1(,R5)                -yes-    Re-set target address
         B     UNPACK                               and Loop back.
         TITLE                     'Read PDS member(s)                 x
                                                Clear text de-blocking'
NOT_PACKED  DS 0H
         STM   R2,R5,SAVE25          Save the registers
         LH    R3,DCBLRECL           Get the LRECL
         LA    R4,0(,R7)             Address the record
         LR    R2,R5                 Move 'to' address
         TM    DCBRECFM,DCBRECF      RECFM=V (not RECFM=F or RECFM=U)
         BO    *+16                     -no -
         ICM   R3,3,0(R7)            Get RDW from the record.
         SH    R3,=H'4'              Calculate the length of the data.
         LA    R4,4(,R7)             Address the data.
         SPACE 1
         L     R1,APARMS             Address the parm list given to me.
         TM    8(R1),X'80'           Two parms?
         BO    *+12                     -yes-
         L     R1,12(,R1)               -no -  Address parm 3 and
         ST    R3,0(,R1)                          put LRECL there.
         SPACE 1
         LR    R5,R3                 Move 'from' length = 'to' length.
         MVCL  R2,R4                 Give caller his copy of the rec.
         L     R2,SAVE25             Restore addressablity.
         ST    R4,MEMAREC            Address of next logical record.
         LM    R3,R5,SAVE25+4        Restore the other registers.
         B     DEBLKXT               Almost done.
         TITLE                     'Read PDS member(s)                 x
                                             WYLBUR deblocking routine'
BLANK15  DC    CL15'               '
         SPACE 3
WYLBLK   DS    0H
         CLC   MEMABLK,MEMAREC
         BNE   *+8
         LA    R7,2(,R7)
         CLI   4(R7),X'00'
         BNE   *+26
         MVI   0(R5),X'40'
         MVC   1(79,R5),0(R5)
         LA    R7,5(,R7)
         ST    R7,MEMAREC
         B     WYLBLK2
         SPACE 1
         SR    R8,R8
         IC    R8,4(,R7)
         LA    R8,5(R7,R8)
         ST    R8,MEMAREC
         SR    R1,R1
         LA    R7,5(,R7)
WYLBLK1  DS    0H
         IC    R1,0(,R7)
         SRA   R1,4
         LR    R14,R1
         BZ    *+20
         BCTR  R1,0
         STC   R1,*+5
         MVC   0(1,R5),BLANK15
         LA    R5,1(R1,R5)
         SPACE 1
         IC    R1,0(,R7)
         SLL   R14,4
         SR    R1,R14
         BZ    *+24
         BCTR  R1,0
         STC   R1,*+5
         MVC   0(1,R5),1(R7)
         LA    R5,1(R1,R5)
         LA    R7,1(R1,R7)
         SPACE 1
         LA    R7,1(,R7)
         CR    R7,R8
         BL    WYLBLK1
WYLBLK2  DS    0H
         L     R8,MEMABLK
         AH    R8,0(,R8)
         CR    R7,R8
         BL    RTNXT
         OI    MEMBER_SW,DO_READ     (Physical) read required.
         B     RTNXT
         TITLE                     'Read PDS member(s)                 x
                                              YSLIM deblocking routine'
YSLIMBLK DS    0H
         LA    R15,72(,R5)
         MVI   0(R5),X'40'
         MVC   1(79,R5),0(R5)
         SR    R1,R1
         CLI   0(R7),X'00'
         BE    YSLIMB8
YSLIMB1  DS    0H
         IC    R1,0(,R7)
         SRL   R1,4
         LR    R14,R1
         AR    R5,R1
         IC    R1,0(,R7)
         SLL   R14,4
         SR    R1,R14
         BZ    YSLIMB2
         BCTR  R1,0
         STC   R1,*+5
         MVC   0(1,R5),1(R7)
         LA    R5,1(R1,R5)
         LA    R7,1(R1,R7)
YSLIMB2  DS    0H
         LA    R7,1(,R7)
         CR    R5,R15
         BNL   YSLIMB8+4
         CLI   0(R7),X'00'
         BNE   YSLIMB1
YSLIMB8  DS    0H
         LA    R7,1(,R7)
         ST    R7,MEMAREC
         B     DEBLKXT
         TITLE                     'Read PDS member(s)                 x
                 Common deblocking exit   /   End-of-member processing'
DEBLKXT  DS    0H
         TM    MEMBER_SW,PACKED_MEMBER  Packed member?
         BZ    DE_BLOCK_XT2                -no -
         L     R1,APARMS             Need my plist.
         TM    8(R1),X'80'           3 parameters?
         BO    DE_BLOCK_XT2             -yes-
         LM    R0,R1,8(R1)              -no - need parm 3 and parm 4.
         SR    R5,R0                 Calculate length of record
         ST    R5,0(,R1)                and return it to the caller.
DE_BLOCK_XT2   DS    0H
         TM    MEMBER_SW,OVERFLOW    Handling a buffer wrap?
         BZ    DE_BLOCK_XT              -no -
         NI    MEMBER_SW,255-OVERFLOW  Turn OFF buffer wrap processing.
         L     R14,MEM_FLOWAREA      Address interim area.
         L     R1,4(,R14)            Length of data from old buffer.
         LA    R14,8(R1,R14)         Address of data from new buffer
         SR    R7,R14                   minus current pointer equals
         A     R7,MEMABLK                  displacement into new buffer
         ST    R7,MEMAREC                     which gets used next CALL
         B     RTNXT
DE_BLOCK_XT DS 0H
         L     R7,MEMAREC
         L     R8,MEMABLK
         AH    R8,MEMBLKL
         CR    R7,R8
         BL    RTNXT
         OI    MEMBER_SW,DO_READ     (Physical) read required.
         B     RTNXT
         SPACE 3
EOMEM    DS    0H
         L     R8,MEMABLK
         TM    MEMBER_SW,PACKED_MEMBER  Was member packed?
         BZ    EOMEM010                    -no -
         L     R1,MEM_FLOWAREA       Need to release
         L     R0,0(,R1)                acquired storage.
      FREEMAIN R,LV=(R0),A=(R1)
EOMEM010 DS    0H
         LA    R4,FREETBL-FREELEN  Top-of-table minus 1 entry
         SPACE 1
         LA    R4,FREELEN(,R4)     Next table entry
         L     R1,FREEADDR         Entry
         LTR   R1,R1                  available for use
         BNZ   *-10                     -no -  loop back.
         LR    R0,R4               Save address of available entry.
         LA    R4,DDAFREE          Get anchor.
         B     EOMEM040
EOMEM020 DS    0H
         LR    R4,R5               One link at a time.
EOMEM040 DS    0H
         L     R5,FREENXT          Is this
         LTR   R5,R5                  the last link?
         BNZ   EOMEM020                  -no -
         ST    R0,FREENXT          Link in next available entry.
         LR    R4,R0               Point to that entry
         ST    R8,FREEADDR            and save the GETMAIN'd address.
         MVI   RC,12
         XC    0(MEMNTRY,R2),0(R2) Clear the member entry.
         MVI   MEMBER_SW,DE_ACTIVE Indicate available entry.
         B     RTNXT
         TITLE                     'Read PDS member(s)                 x
                                                     Global data areas'
APARMS   DS    F
         SPACE 1
DDTBL    DS    0D
         DC    C'        ',3A(0)
         DC    C'        ',3A(0)
         DC    C'        ',3A(0)
         DC    C'        ',3A(0)
         DC    C'        ',3A(0)
         DC    C'        ',3A(0)
         DC    C'        ',3A(0)
         DC    C'        ',3A(0)
DDLAST   DC    C'        ',3A(0)
         SPACE 1
FREETBL  DC    16D'0'
*
* 'FREETBL' is a table containing chains of entries pointing to
* storage which has become free because the buffer is no longer
* required after a member has been read. Note that each chain is
* anchored to a 'DDNTRY' because the DCB determines the amount of
* storage acquired. The total number of (active) 'free' entries is
* controlled by the number of active 'MEMNTRY's.
*
* 'FREETBL" entries are mapped via the 'FREENTRY' DSECT.
         SPACE 1
MEMTBL   DS    0D
         DC    (MEMNTRY)X'00'
         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0
         DC    AL1(DE_ACTIVE)
         ORG
         DC    (MEMNTRY)X'00'
         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0
         DC    AL1(DE_ACTIVE)
         ORG
         DC    (MEMNTRY)X'00'
         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0
         DC    AL1(DE_ACTIVE)
         ORG
         DC    (MEMNTRY)X'00'
         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0
         DC    AL1(DE_ACTIVE)
         ORG
         DC    (MEMNTRY)X'00'
         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0
         DC    AL1(DE_ACTIVE)
         ORG
         DC    (MEMNTRY)X'00'
         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0
         DC    AL1(DE_ACTIVE)
         ORG
         DC    (MEMNTRY)X'00'
         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0
         DC    AL1(DE_ACTIVE)
         ORG
MEMLAST  DC    (MEMNTRY)X'00'
         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0
         DC    AL1(DE_ACTIVE)
         ORG
         SPACE 1
DBLWD    DS    D
         SPACE 1
SAVE25   DS    4F
         SPACE 1
LAST_DD_ENTRY  DS    F
         SPACE 3
A_DCB    DCB   DSORG=PO,                                               X
               MACRF=R,                                                X
               DDNAME=PDS1,                                            X
               EODAD=EOMEM
         SPACE 1
WARN1MSG DS    0F
         DC    AL2(WARN1LEN),XL2'8000'
         DC    C'STSS384  :  ''FIND'' macro generated return code'
WARN1RC  DS    CL4
         DC    C'.'
WARN1LEN EQU   *-WARN1MSG
         DC    X'04000020'
         SPACE 1
ENTRY_SW       DS     XL1
NO_DEBLOCK     EQU    X'01'
YES_DEBLOCK    EQU    X'00'
TTR_MEMBER     EQU    X'10'
         EJECT
         LTORG
         TITLE                     'Read PDS member(s)                 x
                                                    DSECTS and EQUates'
         SPACE 2
IOB000D  DSECT
IOBPREFX DS    0CL16
IOBCFLG1 DS    XL1
         DS    XL15
IOBSTDRD DS    CL8
         DS    XL1
IOBCSW   DS    XL7
         SPACE 2
DDNTRY0  DSECT
DDNAME0  DS    CL8
DDMEM0   DS    XL1
DDADRCT0 DS    AL3
DDADCB0  DS    A
DDAFREE  DS    A
DDNTRY   EQU   *-DDNAME0
         SPACE 2
FREENTRY DSECT
FREENXT  DS    A
FREEADDR DS    A
FREELEN  EQU   *-FREENXT
         SPACE 2
MEMNTRY0 DSECT
MEMNAME0 DS    CL8
MEMDECB  DS    0CL20
         DS    2A
         DS    AL1
MEMADCB  DS    AL3
MEMABLK  DS    F
         DS    AL1
MEMAIOB  DS    AL3
MEMAREC  DS    F
MEM_FLOWAREA   DS    F
MEMBLKL  DS    H
MEMBER_SW      DS    XL1
NEW_MEMBER     EQU  X'80'
PACKED_MEMBER  EQU  X'40'
OVERFLOW       EQU  X'20'
DE_ACTIVE      EQU  X'08'
DO_READ        EQU  X'04'
         DS    0D
MEMNTRY  EQU   *-MEMNAME0
         SPACE 1
         DCBD  DSORG=(PO),DEVD=(DA)
         SPACE 1
         IHADECB
         SPACE 1
         YREGS
         END   STSS384
